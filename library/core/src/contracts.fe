use super::abi::{Abi, AbiEncoder, AbiSize, ByteInput, Encode}

/// Host interface required by compiler-generated contract entrypoints.
///
/// This trait is implemented by the target's root effect type (e.g. `std::evm::effects::Evm`).
pub trait ContractHost {
    /// Higher-kinded pointer type for contract storage fields.
    type FieldPtr: * -> *

    /// ABI input source (e.g. EVM calldata).
    type Input: ByteInput

    fn input(self) -> Self::Input

    fn field<T>(mut self, field_idx: u256) -> Self::FieldPtr<T>
    fn init_field<T>(mut self, field_idx: u256) -> Self::FieldPtr<T> {
        self.field(field_idx)
    }

    fn create_contract<F>(mut self, runtime: F) -> !
    fn abort(self) -> !

    fn return_bytes(self, ptr: u256, len: u256) -> !
    fn return_unit(self) -> ! {
        self.return_bytes(0, 0)
    }

    fn init_decoder<A: Abi>(mut self) -> A::Decoder<Self::Input> {
        A::decoder_new(self.input())
    }

    fn runtime_selector<A: Abi>(self) -> A::Selector {
        let input = self.input()
        if input.len() < A::SELECTOR_SIZE {
            self.abort()
        }
        A::selector_from_prefix(input.word_at(0))
    }

    fn runtime_decoder<A: Abi>(mut self) -> A::Decoder<Self::Input> {
        A::decoder_with_base(self.input(), A::SELECTOR_SIZE)
    }

    fn return_value<A: Abi, T>(mut self, value: T) -> !
        where T: Encode<A> + AbiSize
    {
        let mut enc = A::encoder_new()
        enc.reserve_head(T::ENCODED_SIZE)
        value.encode(enc)
        let out: (u256, u256) = enc.finish()
        self.return_bytes(out.0, out.1)
    }
}

/// Target configuration used by compiler-generated contract entrypoints.
pub trait Target {
    type RootEffect: ContractHost
    type DefaultAbi: Abi
}

pub fn init_field<T, H: ContractHost>(mut host: H, field_idx: u256) -> H::FieldPtr<T> {
    host.init_field(field_idx)
}

pub fn field<T, H: ContractHost>(mut host: H, field_idx: u256) -> H::FieldPtr<T> {
    host.field(field_idx)
}

pub fn init_decoder<A: Abi, H: ContractHost>(mut host: H) -> A::Decoder<H::Input> {
    A::decoder_new(host.input())
}

pub fn runtime_selector<A: Abi, H: ContractHost>(host: H) -> A::Selector {
    let input = host.input()
    if input.len() < A::SELECTOR_SIZE {
        host.abort()
    }
    A::selector_from_prefix(input.word_at(0))
}

pub fn runtime_decoder<A: Abi, H: ContractHost>(mut host: H) -> A::Decoder<H::Input> {
    A::decoder_with_base(host.input(), A::SELECTOR_SIZE)
}

pub fn create_contract<H: ContractHost, F>(mut host: H, runtime: F) -> ! {
    host.create_contract(runtime)
}

pub fn abort<H: ContractHost>(host: H) -> ! {
    host.abort()
}

pub fn return_bytes<H: ContractHost>(host: H, ptr: u256, len: u256) -> ! {
    host.return_bytes(ptr, len)
}

pub fn return_unit<H: ContractHost>(host: H) -> ! {
    host.return_bytes(0, 0)
}

pub fn return_value<A: Abi, H: ContractHost, T>(mut host: H, value: T) -> !
    where T: Encode<A> + AbiSize
{
    let mut enc = A::encoder_new()
    enc.reserve_head(T::ENCODED_SIZE)
    value.encode(enc)
    let out: (u256, u256) = enc.finish()
    host.return_bytes(out.0, out.1)
}
