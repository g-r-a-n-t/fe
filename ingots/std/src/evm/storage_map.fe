use super::effects::Address
use ingot::evm::ops::{keccak256, mload, mstore, sload, sstore}
use ingot::evm::word::WordRepr
use core::{EffectRef, EffectRefMut}

/// Keys that can be written into the mapping preimage for keccak hashing.
pub trait StorageKey {
    /// Writes the key bytes at `ptr` and returns the length written.
    fn write_key(ptr: u256, self) -> u256
}

impl StorageKey for u256 {
    fn write_key(ptr: u256, self) -> u256 {
        mstore(ptr, self)
        32
    }
}

impl StorageKey for Address {
    fn write_key(ptr: u256, self) -> u256 {
        u256::write_key(ptr, self.inner)
    }
}

/// A storage-backed mapping from keys `K` to values `V`.
///
/// `SALT` is the mapping's slot seed (the `slot` component in
/// `keccak256(key ++ slot)`), chosen explicitly for each mapping instance to
/// prevent collisions.
pub struct StorageMap<K, V, const SALT: u256> {}

fn storagemap_storage_slot_with_salt<K>(key: K, salt: u256) -> u256
    where K: StorageKey
{
    // keccak256(key ++ slot) - standard Solidity mapping layout
    // TODO: fn alloc_tmp
    let ptr = mload(0x40)
    let key_len = K::write_key(ptr, key)
    mstore(ptr + key_len, salt)
    keccak256(ptr, key_len + 32)
}

fn storagemap_get_word_with_salt<K>(key: K, salt: u256) -> u256
    where K: StorageKey
{
    let storage_slot = storagemap_storage_slot_with_salt(key, salt)
    sload(storage_slot)
}

fn storagemap_set_word_with_salt<K>(key: K, salt: u256, word: u256)
    where K: StorageKey
{
    let storage_slot = storagemap_storage_slot_with_salt(key, salt)
    sstore(storage_slot, word)
}

impl<K: StorageKey, V: WordRepr, const SALT: u256> StorageMap<K, V, SALT> {
    pub fn new() -> Self {
        Self {}
    }

    pub fn get(self, key: K) -> V {
        V::from_word(word: storagemap_get_word_with_salt(key, SALT))
    }

    pub fn set(self, key: K, value: V) {
        storagemap_set_word_with_salt(key, SALT, value.to_word())
    }
}



impl<A, B> StorageKey for (A, B)
where A: StorageKey,
      B: StorageKey {
    fn write_key(ptr: u256, self) -> u256 {
        let (a, b) = self
        let a_len = A::write_key(ptr, a)
        let b_len = B::write_key(ptr + a_len, b)
        a_len + b_len
    }
}
