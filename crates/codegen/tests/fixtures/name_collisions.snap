---
source: crates/codegen/tests/yul.rs
expression: output
input_file: tests/fixtures/name_collisions.fe
---
function flattened_fn() -> ret {
  ret := 1
  leave
}
function flattened_fn() -> ret {
  ret := 2
  leave
}
function test_module_qualifier_flatten_collision() -> ret {
  let v0 := flattened_fn()
  let v1 := flattened_fn()
  ret := add(v0, v1)
  leave
}
function test_generic_type_collision() -> ret {
  let v0 := mload(0x40)
  if iszero(v0) {
    v0 := 0x80
  }
  mstore(0x40, add(v0, 4))
  mstore(v0, and(1, 0xffffffff))
  let v1 := v0
  let v2 := mload(0x40)
  if iszero(v2) {
    v2 := 0x80
  }
  mstore(0x40, add(v2, 8))
  mstore(v2, and(2, 0xffffffffffffffff))
  let v3 := v2
  let v4 := generic_fn__S__33f7c3322e562590(v1)
  pop(v4)
  let v5 := generic_fn__S__33f7c3322e562590(v3)
  pop(v5)
  ret := 42
  leave
}
function impl_a_widget_process(self) -> ret {
  let v0 := and(mload(self), 0xffffffff)
  ret := mul(v0, 2)
  leave
}
function impl_b_widget_process(self) -> ret {
  let v0 := and(mload(self), 0xffffffffffffffff)
  ret := mul(v0, 3)
  leave
}
function test_impl_method_collision() -> ret {
  let v0 := mload(0x40)
  if iszero(v0) {
    v0 := 0x80
  }
  mstore(0x40, add(v0, 4))
  mstore(v0, and(10, 0xffffffff))
  let v1 := v0
  let v2 := mload(0x40)
  if iszero(v2) {
    v2 := 0x80
  }
  mstore(0x40, add(v2, 8))
  mstore(v2, and(20, 0xffffffffffffffff))
  let v3 := v2
  let v4 := widget_process_mem(v1)
  let v5 := widget_process_mem(v3)
  ret := v4
  leave
}
function multitraitimpl_trait_same_method(self) -> ret {
  let v0 := and(mload(self), 0xffffffff)
  ret := add(v0, 1)
  leave
}
function multitraitimpl_trait_same_method(self) -> ret {
  let v0 := and(mload(self), 0xffffffff)
  ret := add(v0, 2)
  leave
}
function test_trait_method_collision() -> ret {
  let v0 := mload(0x40)
  if iszero(v0) {
    v0 := 0x80
  }
  mstore(0x40, add(v0, 4))
  mstore(v0, and(100, 0xffffffff))
  let v1 := v0
  let v2 := multitraitimpl_trait_same_method(v1)
  let v3 := mload(0x40)
  if iszero(v3) {
    v3 := 0x80
  }
  mstore(0x40, add(v3, 4))
  mstore(v3, and(100, 0xffffffff))
  let v4 := v3
  let v5 := multitraitimpl_trait_same_method(v4)
  ret := add(v2, v5)
  leave
}
function param_local_collision(v0) -> ret {
  let v0 := add(v0, 1)
  let v1 := add(v0, 2)
  ret := v1
  leave
}
function test_param_local_collision() -> ret {
  let v0 := param_local_collision(10)
  ret := v0
  leave
}
function __u32_as_u256(x) -> ret {
  let v0 := 999
  ret := v0
  leave
}
function test_cast_shim_collision() -> ret {
  let v0 := 42
  ret := v0
  leave
}
function ret_param_collision(ret) -> ret {
  ret := add(ret, 1)
  leave
}
function test_ret_param_collision() -> ret {
  let v0 := ret_param_collision(10)
  ret := v0
  leave
}
function add() -> ret {
  ret := 123
  leave
}
function test_yul_reserved_fn_collision() -> ret {
  let v0 := add()
  ret := v0
  leave
}
function main() -> ret {
  let v0 := test_module_qualifier_flatten_collision()
  pop(v0)
  let v1 := test_generic_type_collision()
  pop(v1)
  let v2 := test_impl_method_collision()
  pop(v2)
  let v3 := test_trait_method_collision()
  pop(v3)
  let v4 := test_param_local_collision()
  pop(v4)
  let v5 := test_cast_shim_collision()
  pop(v5)
  let v6 := test_ret_param_collision()
  pop(v6)
  let v7 := test_yul_reserved_fn_collision()
  pop(v7)
  ret := 0
  leave
}
function generic_fn__S__33f7c3322e562590(val) -> ret {
  ret := val
  leave
}
function generic_fn__S__33f7c3322e562590(val) -> ret {
  ret := val
  leave
}
function widget_process_mem(self) -> ret {
  let v0 := and(mload(self), 0xffffffff)
  ret := mul(v0, 2)
  leave
}
function widget_process_mem(self) -> ret {
  let v0 := and(mload(self), 0xffffffffffffffff)
  ret := mul(v0, 3)
  leave
}
