use std::evm::{Evm, RawMem, RawOps, RawStorage, StorageMap, StorPtr}

const BALANCES_SALT: u256 = 0
const ALLOWANCES_SALT: u256 = 1

fn abi_encode(value: u256) -> ! uses (mut ops: RawOps) {
    let ptr: u256 = 0
    ops.mstore(ptr, value)
    ops.return_data(ptr, 32)
}

// Two separate StorageMaps - balances and allowances
fn get_balance(addr: u256) -> u256
    uses (balances: StorageMap<u256, u256, BALANCES_SALT>)
{
    balances.get(key: addr)
}

fn set_balance(addr: u256, value: u256)
    uses (mut balances: StorageMap<u256, u256, BALANCES_SALT>)
{
    balances.set(key: addr, value)
}

fn get_allowance(addr: u256) -> u256
    uses (allowances: StorageMap<u256, u256, ALLOWANCES_SALT>)
{
    allowances.get(key: addr)
}

fn set_allowance(addr: u256, value: u256)
    uses (mut allowances: StorageMap<u256, u256, ALLOWANCES_SALT>)
{
    allowances.set(key: addr, value)
}

fn transfer(from: u256, to: u256, amount: u256) -> u256
    uses (mut balances: StorageMap<u256, u256, BALANCES_SALT>)
{
    let from_balance = balances.get(key: from)
    if from_balance < amount {
        return 1  // insufficient funds
    }
    let to_balance = balances.get(key: to)
    balances.set(key: from, value: from_balance - amount)
    balances.set(key: to, value: to_balance + amount)
    0  // success
}

#[contract_init(BalanceMap)]
fn init() uses (mut evm: Evm) {
    let len = evm.code_region_len(runtime)
    let offset = evm.code_region_offset(runtime)
    evm.codecopy(dest: 0, offset, len)
    evm.return_data(0, len)
}

#[contract_runtime(BalanceMap)]
fn runtime() uses (mut evm: Evm) {
    let mut balances: StorageMap<u256, u256, BALANCES_SALT> = StorageMap::new()
    let mut allowances: StorageMap<u256, u256, ALLOWANCES_SALT> = StorageMap::new()
    let selector = evm.calldataload(0) >> 224
    with (RawOps = evm) {
        match selector {
            0x9cc7f708 => {
                // balanceOf(uint256)
                let addr = evm.calldataload(4)
                let balance = with (balances) {
                    get_balance(addr)
                }
                abi_encode(value: balance)
            }
            0x4a4b9feb => {
                // setBalance(uint256,uint256)
                let addr = evm.calldataload(4)
                let value = evm.calldataload(36)
                with (balances) {
                    set_balance(addr, value)
                }
                abi_encode(value: 0)
            }
            0x90dd2627 => {
                // transfer(uint256,uint256,uint256)
                let from = evm.calldataload(4)
                let to = evm.calldataload(36)
                let amount = evm.calldataload(68)
                let result = with (balances) { transfer(from, to, amount) }
                abi_encode(value: result)
            }
            0xc960174e => {
                // getAllowance(uint256)
                let addr = evm.calldataload(4)
                let allowance = with (allowances) { get_allowance(addr) }
                abi_encode(value: allowance)
            }
            0x0bca4841 => {
                // setAllowance(uint256,uint256)
                let addr = evm.calldataload(4)
                let value = evm.calldataload(36)
                with (allowances) {
                    set_allowance(addr, value)
                }
                abi_encode(value: 0)
            }
            _ => evm.return_data(0, 0)
        }
    }
}
