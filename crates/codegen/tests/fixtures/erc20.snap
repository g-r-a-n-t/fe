---
source: crates/codegen/tests/yul.rs
expression: output
input_file: tests/fixtures/erc20.fe
---
object "CoolCoin" {
  code {
    function __coolcoin_init() {
      let v0 := init_field__Evm_TokenStore__f6aa99d6ecaccf30(0, 0)
      let v1 := init_field__Evm_AccessControl__9eae422fa78e0dfe(0, 3)
      let v2 := evm_contracthost_init_input__fn_runtime__7cd036468b9a6201(0, 0)
      let v3 := sol_abi_decoder_new__MemoryBytes__b48f82585f3ed728(v2)
      let v4 := u256_decode_decode__Sol_SolDecoder_MemoryBytes___c66d50dfccf37f39(v3)
      let v5 := address_decode_decode__Sol_SolDecoder_MemoryBytes___c66d50dfccf37f39(v3)
      let v6 := v0
      let v7 := v1
      init_contract(v4, v5, v6, v7, 0, 0)
      evm_contracthost_create_contract__fn_runtime__7cd036468b9a6201(0, 0)
      leave
    }
    function _a__b__storagekey_write_key__u256_Address__1ae3ad2a1b729a8b(ptr, self) -> ret {
      let v0 := mload(self)
      let v1 := add(self, 32)
      let v2 := u256_storagekey_write_key(ptr, v0)
      let v3 := address_storagekey_write_key(add(ptr, v2), v1)
      ret := add(v2, v3)
      leave
    }
    function accesscontrol_grant_stor(self, role, to) {
      let v0 := mload(0x40)
      if iszero(v0) {
        v0 := 0x80
      }
      mstore(0x40, add(v0, 64))
      mstore(v0, role)
      let v1 := to
      mstore(add(v0, 32), mload(v1))
      storagemap_k__v__set_stor___u256__Address__bool__ac1f217814dd9c46(self, v0, 1)
      leave
    }
    function address_decode_decode__Sol_SolDecoder_MemoryBytes___c66d50dfccf37f39(d) -> ret {
      let v0 := soldecoder_i__abidecoder_read_word__MemoryBytes__b48f82585f3ed728(d)
      let v1 := mload(0x40)
      if iszero(v1) {
        v1 := 0x80
      }
      mstore(0x40, add(v1, 32))
      mstore(v1, v0)
      ret := v1
      leave
    }
    function address_storagekey_write_key(ptr, self) -> ret {
      let v0 := mload(self)
      let v1 := u256_storagekey_write_key(ptr, v0)
      ret := v1
      leave
    }
    function address_zero() -> ret {
      let v0 := mload(0x40)
      if iszero(v0) {
        v0 := 0x80
      }
      mstore(0x40, add(v0, 32))
      mstore(v0, 0)
      ret := v0
      leave
    }
    function alloc(size) -> ret {
      let v0 := mload(64)
      let v1 := eq(v0, 0)
      if v1 {
        v0 := 128
      }
      mstore(64, add(v0, size))
      ret := v0
      leave
    }
    function assert(b) {
      let v0 := iszero(b)
      if v0 {
        revert(0, 0)
      }
      leave
    }
    function bool_wordrepr_to_word(self) -> ret {
      let v0 := 0
      switch self
        case 1 {
          v0 := 1
        }
        case 0 {
          v0 := 0
        }
        default {
          v0 := 0
        }
      ret := v0
      leave
    }
    function cursor_i__new__MemoryBytes__b48f82585f3ed728(input) -> ret {
      let v0 := mload(0x40)
      if iszero(v0) {
        v0 := 0x80
      }
      mstore(0x40, add(v0, 96))
      let v1 := input
      mstore(v0, mload(v1))
      mstore(add(v0, 32), mload(add(v1, 32)))
      mstore(add(v0, 64), 0)
      let v2 := v0
      ret := v2
      leave
    }
    function emit__log__Log_TransferEvent__41b584f23318b0be(self, event) {
      leave
    }
    function evm_contracthost_abort(self) {
      revert(0, 0)
    }
    function evm_contracthost_create_contract__fn_runtime__7cd036468b9a6201(self, runtime) {
      let v0 := datasize("CoolCoin_deployed")
      let v1 := dataoffset("CoolCoin_deployed")
      codecopy(0, v1, v0)
      return(0, v0)
    }
    function evm_contracthost_field__AccessControl__56bc16b6aa1a86f2(self, slot) -> ret {
      let v0 := stor_ptr__Evm_AccessControl__9eae422fa78e0dfe(0, slot)
      ret := v0
      leave
    }
    function evm_contracthost_field__TokenStore__cf27701b626eb0c2(self, slot) -> ret {
      let v0 := stor_ptr__Evm_TokenStore__f6aa99d6ecaccf30(0, slot)
      ret := v0
      leave
    }
    function evm_contracthost_init_input__fn_runtime__7cd036468b9a6201(self, runtime) -> ret {
      let v0 := dataoffset("CoolCoin_deployed")
      let v1 := datasize("CoolCoin_deployed")
      let v2 := add(v0, v1)
      let v3 := codesize()
      let v4 := lt(v3, v2)
      if v4 {
        evm_contracthost_abort(0)
      }
      let v5 := sub(v3, v2)
      let v6 := alloc(v5)
      codecopy(v6, v2, v5)
      let v7 := mload(0x40)
      if iszero(v7) {
        v7 := 0x80
      }
      mstore(0x40, add(v7, 64))
      mstore(v7, v6)
      mstore(add(v7, 32), v5)
      ret := v7
      leave
    }
    function init_contract(initial_supply, owner, store, auth, ctx, log) {
      accesscontrol_grant_stor(auth, 1, owner)
      accesscontrol_grant_stor(auth, 2, owner)
      let v0 := gt(initial_supply, 0)
      if v0 {
        mint(owner, initial_supply, store, log)
      }
      leave
    }
    function init_field__Evm_AccessControl__9eae422fa78e0dfe(self, slot) -> ret {
      let v0 := evm_contracthost_field__AccessControl__56bc16b6aa1a86f2(self, slot)
      ret := v0
      leave
    }
    function init_field__Evm_TokenStore__f6aa99d6ecaccf30(self, slot) -> ret {
      let v0 := evm_contracthost_field__TokenStore__cf27701b626eb0c2(self, slot)
      ret := v0
      leave
    }
    function memorybytes_byteinput_len(self) -> ret {
      let v0 := mload(add(self, 32))
      ret := v0
      leave
    }
    function memorybytes_byteinput_word_at(self, byte_offset) -> ret {
      let v0 := mload(self)
      let v1 := mload(add(v0, byte_offset))
      ret := v1
      leave
    }
    function mint(to, amount, store, log) {
      let v0 := address_zero()
      assert(iszero(eq(to, v0)))
      let v1 := sload(store)
      sstore(store, add(v1, amount))
      let v2 := storagemap_k__v__get_stor__Address_u256__cdd966cb4c9acb9d(add(store, 1), to)
      storagemap_k__v__set_stor__Address_u256__cdd966cb4c9acb9d(add(store, 1), to, add(v2, amount))
      let v3 := address_zero()
      let v4 := mload(0x40)
      if iszero(v4) {
        v4 := 0x80
      }
      mstore(0x40, add(v4, 96))
      let v5 := v3
      mstore(v4, mload(v5))
      let v6 := to
      mstore(add(v4, 32), mload(v6))
      mstore(add(v4, 64), amount)
      emit__log__Log_TransferEvent__41b584f23318b0be(log, v4)
      leave
    }
    function sol_abi_decoder_new__MemoryBytes__b48f82585f3ed728(input) -> ret {
      let v0 := soldecoder_i__new__MemoryBytes__b48f82585f3ed728(input)
      ret := v0
      leave
    }
    function soldecoder_i__abidecoder_read_word__MemoryBytes__b48f82585f3ed728(self) -> ret {
      let v0 := memorybytes_byteinput_len(self)
      let v1 := mload(add(self, 64))
      let v2 := add(v1, 32)
      let v3 := mload(add(self, 64))
      let v4 := or(lt(v2, v3), gt(v2, v0))
      if v4 {
        revert(0, 0)
      }
      let v5 := mload(add(self, 64))
      let v6 := memorybytes_byteinput_word_at(self, v5)
      mstore(add(self, 64), v2)
      ret := v6
      leave
    }
    function soldecoder_i__new__MemoryBytes__b48f82585f3ed728(input) -> ret {
      let v0 := cursor_i__new__MemoryBytes__b48f82585f3ed728(input)
      let v1 := mload(0x40)
      if iszero(v1) {
        v1 := 0x80
      }
      mstore(0x40, add(v1, 128))
      let v2 := v0
      mstore(v1, mload(v2))
      mstore(add(v1, 32), mload(add(v2, 32)))
      mstore(add(v1, 64), mload(add(v2, 64)))
      mstore(add(v1, 96), 0)
      let v3 := v1
      ret := v3
      leave
    }
    function stor_ptr__Evm_AccessControl__9eae422fa78e0dfe(self, slot) -> ret {
      ret := slot
      leave
    }
    function stor_ptr__Evm_TokenStore__f6aa99d6ecaccf30(self, slot) -> ret {
      ret := slot
      leave
    }
    function storagemap_k__v__get_stor__Address_u256__cdd966cb4c9acb9d(self, key) -> ret {
      let v0 := storagemap_k__v__storage_slot_stor__Address_u256__cdd966cb4c9acb9d(self, key)
      let v1 := sload(v0)
      let v2 := u256_wordrepr_from_word(v1)
      ret := v2
      leave
    }
    function storagemap_k__v__set_stor__Address_u256__cdd966cb4c9acb9d(self, key, value) {
      let v0 := storagemap_k__v__storage_slot_stor__Address_u256__cdd966cb4c9acb9d(self, key)
      let v1 := u256_wordrepr_to_word(value)
      sstore(v0, v1)
      leave
    }
    function storagemap_k__v__set_stor___u256__Address__bool__ac1f217814dd9c46(self, key, value) {
      let v0 := storagemap_k__v__storage_slot_stor___u256__Address__bool__ac1f217814dd9c46(self, key)
      let v1 := bool_wordrepr_to_word(value)
      sstore(v0, v1)
      leave
    }
    function storagemap_k__v__storage_slot_stor__Address_u256__cdd966cb4c9acb9d(self, key) -> ret {
      let v0 := mload(64)
      let v1 := address_storagekey_write_key(v0, key)
      let v2 := self
      mstore(add(v0, v1), v2)
      let v3 := keccak256(v0, add(v1, 32))
      ret := v3
      leave
    }
    function storagemap_k__v__storage_slot_stor___u256__Address__bool__ac1f217814dd9c46(self, key) -> ret {
      let v0 := mload(64)
      let v1 := _a__b__storagekey_write_key__u256_Address__1ae3ad2a1b729a8b(v0, key)
      let v2 := self
      mstore(add(v0, v1), v2)
      let v3 := keccak256(v0, add(v1, 32))
      ret := v3
      leave
    }
    function u256_decode_decode__Sol_SolDecoder_MemoryBytes___c66d50dfccf37f39(d) -> ret {
      let v0 := soldecoder_i__abidecoder_read_word__MemoryBytes__b48f82585f3ed728(d)
      ret := v0
      leave
    }
    function u256_storagekey_write_key(ptr, self) -> ret {
      mstore(ptr, self)
      ret := 32
      leave
    }
    function u256_wordrepr_from_word(word) -> ret {
      ret := word
      leave
    }
    function u256_wordrepr_to_word(self) -> ret {
      ret := self
      leave
    }
    __coolcoin_init()
  }

  object "CoolCoin_deployed" {
    code {
      function ___decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d) {
        leave
      }
      function _a__b__storagekey_write_key__Address_Address__397b9a625a435b6f(ptr, self) -> ret {
        let v0 := self
        let v1 := add(self, 32)
        let v2 := address_storagekey_write_key(ptr, v0)
        let v3 := address_storagekey_write_key(add(ptr, v2), v1)
        ret := add(v2, v3)
        leave
      }
      function _a__b__storagekey_write_key__u256_Address__1ae3ad2a1b729a8b(ptr, self) -> ret {
        let v0 := mload(self)
        let v1 := add(self, 32)
        let v2 := u256_storagekey_write_key(ptr, v0)
        let v3 := address_storagekey_write_key(add(ptr, v2), v1)
        ret := add(v2, v3)
        leave
      }
      function _t0__decode_decode__Sol_Address_SolDecoder_CallData___c3cd70daebc6e8b9(d) -> ret {
        let v0 := address_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d)
        let v1 := mload(0x40)
        if iszero(v1) {
          v1 := 0x80
        }
        mstore(0x40, add(v1, 32))
        let v2 := v0
        mstore(v1, mload(v2))
        ret := v1
        leave
      }
      function _t0__decode_decode__Sol_u256_SolDecoder_CallData___51fc2f6931ec5edc(d) -> ret {
        let v0 := u256_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d)
        let v1 := mload(0x40)
        if iszero(v1) {
          v1 := 0x80
        }
        mstore(0x40, add(v1, 32))
        mstore(v1, v0)
        ret := v1
        leave
      }
      function _t0__t1__decode_decode__Sol_Address_Address_SolDecoder_CallData___7ed19c3f9fd70917(d) -> ret {
        let v0 := address_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d)
        let v1 := address_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d)
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 64))
        let v3 := v0
        mstore(v2, mload(v3))
        let v4 := v1
        mstore(add(v2, 32), mload(v4))
        ret := v2
        leave
      }
      function _t0__t1__decode_decode__Sol_Address_u256_SolDecoder_CallData___25b1373fd1f61181(d) -> ret {
        let v0 := address_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d)
        let v1 := u256_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d)
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 64))
        let v3 := v0
        mstore(v2, mload(v3))
        mstore(add(v2, 32), v1)
        ret := v2
        leave
      }
      function _t0__t1__t2__decode_decode__Sol_Address_Address_u256_SolDecoder_CallData___da321e92055b22cd(d) -> ret {
        let v0 := address_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d)
        let v1 := address_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d)
        let v2 := u256_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d)
        let v3 := mload(0x40)
        if iszero(v3) {
          v3 := 0x80
        }
        mstore(0x40, add(v3, 96))
        let v4 := v0
        mstore(v3, mload(v4))
        let v5 := v1
        mstore(add(v3, 32), mload(v5))
        mstore(add(v3, 64), v2)
        ret := v3
        leave
      }
      function accesscontrol_require_stor(self, role, ctx) {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 32))
        let v1 := caller()
        mstore(v0, v1)
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 64))
        mstore(v2, role)
        let v3 := v0
        mstore(add(v2, 32), mload(v3))
        let v4 := storagemap_k__v__get_stor___u256__Address__bool__ac1f217814dd9c46(self, v2)
        assert(eq(v4, 1))
        leave
      }
      function address_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d) -> ret {
        let v0 := soldecoder_i__abidecoder_read_word__CallData__b9ab8dc8a4b2f9e(d)
        let v1 := mload(0x40)
        if iszero(v1) {
          v1 := 0x80
        }
        mstore(0x40, add(v1, 32))
        mstore(v1, v0)
        ret := v1
        leave
      }
      function address_storagekey_write_key(ptr, self) -> ret {
        let v0 := mload(self)
        let v1 := u256_storagekey_write_key(ptr, v0)
        ret := v1
        leave
      }
      function address_zero() -> ret {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 32))
        mstore(v0, 0)
        ret := v0
        leave
      }
      function alloc(size) -> ret {
        let v0 := mload(64)
        let v1 := eq(v0, 0)
        if v1 {
          v0 := 128
        }
        mstore(64, add(v0, size))
        ret := v0
        leave
      }
      function approve(owner, spender, amount, store, log) {
        let v0 := address_zero()
        assert(iszero(eq(owner, v0)))
        let v1 := address_zero()
        assert(iszero(eq(spender, v1)))
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 64))
        let v3 := owner
        mstore(v2, mload(v3))
        let v4 := spender
        mstore(add(v2, 32), mload(v4))
        storagemap_k__v__set_stor___Address__Address__u256__380d6b10c386a4ee(add(store, 2), v2, amount)
        let v5 := mload(0x40)
        if iszero(v5) {
          v5 := 0x80
        }
        mstore(0x40, add(v5, 96))
        let v6 := owner
        mstore(v5, mload(v6))
        let v7 := spender
        mstore(add(v5, 32), mload(v7))
        mstore(add(v5, 64), amount)
        emit__log__Log_ApprovalEvent__bbf50d88fed22fda(log, v5)
        leave
      }
      function assert(b) {
        let v0 := iszero(b)
        if v0 {
          revert(0, 0)
        }
        leave
      }
      function bool_encode_encode__Sol_SolEncoder__dce63ad1a1fe4ae2(self, e) {
        let v0 := self
        if v0 {
          solencoder_abiencoder_write_word(e, 1)
        }
        if iszero(v0) {
          solencoder_abiencoder_write_word(e, 0)
        }
        leave
      }
      function bool_wordrepr_from_word(word) -> ret {
        ret := iszero(eq(word, 0))
        leave
      }
      function burn(from, amount, store, log) {
        let v0 := address_zero()
        assert(iszero(eq(from, v0)))
        let v1 := storagemap_k__v__get_stor__Address_u256__cdd966cb4c9acb9d(add(store, 1), from)
        assert(iszero(lt(v1, amount)))
        storagemap_k__v__set_stor__Address_u256__cdd966cb4c9acb9d(add(store, 1), from, sub(v1, amount))
        let v2 := sload(store)
        sstore(store, sub(v2, amount))
        let v3 := address_zero()
        let v4 := mload(0x40)
        if iszero(v4) {
          v4 := 0x80
        }
        mstore(0x40, add(v4, 96))
        let v5 := from
        mstore(v4, mload(v5))
        let v6 := v3
        mstore(add(v4, 32), mload(v6))
        mstore(add(v4, 64), amount)
        emit__log__Log_TransferEvent__41b584f23318b0be(log, v4)
        leave
      }
      function calldata_byteinput_len(self) -> ret {
        let v0 := calldatasize()
        let v1 := mload(self)
        ret := sub(v0, v1)
        leave
      }
      function calldata_byteinput_word_at(self, byte_offset) -> ret {
        let v0 := mload(self)
        let v1 := calldataload(add(v0, byte_offset))
        ret := v1
        leave
      }
      function cursor_i__fork_mem__CallData__b9ab8dc8a4b2f9e(self, pos) -> ret {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 64))
        let v1 := self
        mstore(v0, mload(v1))
        mstore(add(v0, 32), pos)
        let v2 := v0
        ret := v2
        leave
      }
      function cursor_i__new__MemoryBytes__b48f82585f3ed728(input) -> ret {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 96))
        let v1 := input
        mstore(v0, mload(v1))
        mstore(add(v0, 32), mload(add(v1, 32)))
        mstore(add(v0, 64), 0)
        let v2 := v0
        ret := v2
        leave
      }
      function emit__log__Log_ApprovalEvent__bbf50d88fed22fda(self, event) {
        leave
      }
      function emit__log__Log_TransferEvent__41b584f23318b0be(self, event) {
        leave
      }
      function evm_contracthost_abort(self) {
        revert(0, 0)
      }
      function evm_contracthost_field__AccessControl__56bc16b6aa1a86f2(self, slot) -> ret {
        let v0 := stor_ptr__Evm_AccessControl__9eae422fa78e0dfe(0, slot)
        ret := v0
        leave
      }
      function evm_contracthost_field__TokenStore__cf27701b626eb0c2(self, slot) -> ret {
        let v0 := stor_ptr__Evm_TokenStore__f6aa99d6ecaccf30(0, slot)
        ret := v0
        leave
      }
      function evm_contracthost_input(self) -> ret {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 32))
        mstore(v0, 0)
        ret := v0
        leave
      }
      function evm_contracthost_return_bytes(self, ptr, len) {
        return(ptr, len)
      }
      function mint(to, amount, store, log) {
        let v0 := address_zero()
        assert(iszero(eq(to, v0)))
        let v1 := sload(store)
        sstore(store, add(v1, amount))
        let v2 := storagemap_k__v__get_stor__Address_u256__cdd966cb4c9acb9d(add(store, 1), to)
        storagemap_k__v__set_stor__Address_u256__cdd966cb4c9acb9d(add(store, 1), to, add(v2, amount))
        let v3 := address_zero()
        let v4 := mload(0x40)
        if iszero(v4) {
          v4 := 0x80
        }
        mstore(0x40, add(v4, 96))
        let v5 := v3
        mstore(v4, mload(v5))
        let v6 := to
        mstore(add(v4, 32), mload(v6))
        mstore(add(v4, 64), amount)
        emit__log__Log_TransferEvent__41b584f23318b0be(log, v4)
        leave
      }
      function recv_Erc20Extended_BurnFrom_1_2(args, ctx, store, log) -> ret {
        let v0 := args
        let v1 := mload(add(args, 32))
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 32))
        let v3 := caller()
        mstore(v2, v3)
        spend_allowance(v0, v2, v1, store)
        burn(v0, v1, store, log)
        ret := 1
        leave
      }
      function recv_Erc20Extended_Burn_1_1(args, ctx, store, log) -> ret {
        let v0 := mload(args)
        let v1 := mload(0x40)
        if iszero(v1) {
          v1 := 0x80
        }
        mstore(0x40, add(v1, 32))
        let v2 := caller()
        mstore(v1, v2)
        burn(v1, v0, store, log)
        ret := 1
        leave
      }
      function recv_Erc20Extended_DecreaseAllowance_1_4(args, ctx, store, log) -> ret {
        let v0 := args
        let v1 := mload(add(args, 32))
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 32))
        let v3 := caller()
        mstore(v2, v3)
        let v4 := mload(0x40)
        if iszero(v4) {
          v4 := 0x80
        }
        mstore(0x40, add(v4, 64))
        let v5 := v2
        mstore(v4, mload(v5))
        let v6 := v0
        mstore(add(v4, 32), mload(v6))
        let v7 := storagemap_k__v__get_stor___Address__Address__u256__380d6b10c386a4ee(add(store, 2), v4)
        assert(iszero(lt(v7, v1)))
        approve(v2, v0, sub(v7, v1), store, log)
        ret := 1
        leave
      }
      function recv_Erc20Extended_IncreaseAllowance_1_3(args, ctx, store, log) -> ret {
        let v0 := args
        let v1 := mload(add(args, 32))
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 32))
        let v3 := caller()
        mstore(v2, v3)
        let v4 := mload(0x40)
        if iszero(v4) {
          v4 := 0x80
        }
        mstore(0x40, add(v4, 64))
        let v5 := v2
        mstore(v4, mload(v5))
        let v6 := v0
        mstore(add(v4, 32), mload(v6))
        let v7 := storagemap_k__v__get_stor___Address__Address__u256__380d6b10c386a4ee(add(store, 2), v4)
        approve(v2, v0, add(v7, v1), store, log)
        ret := 1
        leave
      }
      function recv_Erc20Extended_Mint_1_0(args, ctx, store, log, auth) -> ret {
        let v0 := args
        let v1 := mload(add(args, 32))
        accesscontrol_require_stor(auth, 1, ctx)
        mint(v0, v1, store, log)
        ret := 1
        leave
      }
      function recv_Erc20_Allowance_0_4(args, store) -> ret {
        let v0 := args
        let v1 := add(args, 32)
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 64))
        let v3 := v0
        mstore(v2, mload(v3))
        let v4 := v1
        mstore(add(v2, 32), mload(v4))
        let v5 := storagemap_k__v__get_stor___Address__Address__u256__380d6b10c386a4ee(add(store, 2), v2)
        ret := v5
        leave
      }
      function recv_Erc20_Approve_0_1(args, ctx, store, log) -> ret {
        let v0 := args
        let v1 := mload(add(args, 32))
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 32))
        let v3 := caller()
        mstore(v2, v3)
        approve(v2, v0, v1, store, log)
        ret := 1
        leave
      }
      function recv_Erc20_BalanceOf_0_3(args, store) -> ret {
        let v0 := args
        let v1 := storagemap_k__v__get_stor__Address_u256__cdd966cb4c9acb9d(add(store, 1), v0)
        ret := v1
        leave
      }
      function recv_Erc20_Decimals_0_8(args) -> ret {
        ret := 18
        leave
      }
      function recv_Erc20_Name_0_6(args) -> ret {
        ret := 0x436f6f6c436f696e
        leave
      }
      function recv_Erc20_Symbol_0_7(args) -> ret {
        ret := 0x434f4f4c
        leave
      }
      function recv_Erc20_TotalSupply_0_5(args, store) -> ret {
        let v0 := sload(store)
        ret := v0
        leave
      }
      function recv_Erc20_TransferFrom_0_2(args, ctx, store, log) -> ret {
        let v0 := args
        let v1 := add(args, 32)
        let v2 := mload(add(args, 64))
        let v3 := mload(0x40)
        if iszero(v3) {
          v3 := 0x80
        }
        mstore(0x40, add(v3, 32))
        let v4 := caller()
        mstore(v3, v4)
        spend_allowance(v0, v3, v2, store)
        transfer(v0, v1, v2, store, log)
        ret := 1
        leave
      }
      function recv_Erc20_Transfer_0_0(args, ctx, store, log) -> ret {
        let v0 := args
        let v1 := mload(add(args, 32))
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 32))
        let v3 := caller()
        mstore(v2, v3)
        transfer(v2, v0, v1, store, log)
        ret := 1
        leave
      }
      function return_value__Evm_Sol_String_32___fce5fd9d073f47ee(self, value) {
        let v0 := sol_abi_encoder_new()
        let v1 := solencoder_abiencoder_reserve_head(v0, 32)
        pop(v1)
        string_const_n__usize__encode_encode__Sol_32_SolEncoder__85bcb27fa2f25e8f(value, v0)
        let v2 := solencoder_abiencoder_finish(v0)
        let v3 := mload(v2)
        let v4 := mload(add(v2, 32))
        evm_contracthost_return_bytes(self, v3, v4)
      }
      function return_value__Evm_Sol_String_8___90b3a09bdf47bf15(self, value) {
        let v0 := sol_abi_encoder_new()
        let v1 := solencoder_abiencoder_reserve_head(v0, 32)
        pop(v1)
        string_const_n__usize__encode_encode__Sol_32_SolEncoder__85bcb27fa2f25e8f(value, v0)
        let v2 := solencoder_abiencoder_finish(v0)
        let v3 := mload(v2)
        let v4 := mload(add(v2, 32))
        evm_contracthost_return_bytes(self, v3, v4)
      }
      function return_value__Evm_Sol_bool__261f3a707fad09c8(self, value) {
        let v0 := sol_abi_encoder_new()
        let v1 := solencoder_abiencoder_reserve_head(v0, 32)
        pop(v1)
        bool_encode_encode__Sol_SolEncoder__dce63ad1a1fe4ae2(value, v0)
        let v2 := solencoder_abiencoder_finish(v0)
        let v3 := mload(v2)
        let v4 := mload(add(v2, 32))
        evm_contracthost_return_bytes(self, v3, v4)
      }
      function return_value__Evm_Sol_u256__fe091c64bccbbbf1(self, value) {
        let v0 := sol_abi_encoder_new()
        let v1 := solencoder_abiencoder_reserve_head(v0, 32)
        pop(v1)
        u256_encode_encode__Sol_SolEncoder__dce63ad1a1fe4ae2(value, v0)
        let v2 := solencoder_abiencoder_finish(v0)
        let v3 := mload(v2)
        let v4 := mload(add(v2, 32))
        evm_contracthost_return_bytes(self, v3, v4)
      }
      function return_value__Evm_Sol_u8__d483d38efd15a73d(self, value) {
        let v0 := sol_abi_encoder_new()
        let v1 := solencoder_abiencoder_reserve_head(v0, 32)
        pop(v1)
        u8_encode_encode__Sol_SolEncoder__dce63ad1a1fe4ae2(value, v0)
        let v2 := solencoder_abiencoder_finish(v0)
        let v3 := mload(v2)
        let v4 := mload(add(v2, 32))
        evm_contracthost_return_bytes(self, v3, v4)
      }
      function runtime() {
        let v0 := evm_contracthost_field__TokenStore__cf27701b626eb0c2(0, 0)
        let v1 := evm_contracthost_field__AccessControl__56bc16b6aa1a86f2(0, 3)
        let v2 := runtime_selector__Evm_Sol__2533f5c49b57a682(0)
        let v3 := runtime_decoder__Evm_Sol__2533f5c49b57a682(0)
        switch v2
          case 2835717307 {
            let v4 := _t0__t1__decode_decode__Sol_Address_u256_SolDecoder_CallData___25b1373fd1f61181(v3)
            let v5 := v0
            let v6 := recv_Erc20_Transfer_0_0(v4, 0, v5, 0)
            let v7 := v6
            return_value__Evm_Sol_bool__261f3a707fad09c8(0, v7)
          }
          case 157198259 {
            let v8 := _t0__t1__decode_decode__Sol_Address_u256_SolDecoder_CallData___25b1373fd1f61181(v3)
            let v9 := v0
            let v10 := recv_Erc20_Approve_0_1(v8, 0, v9, 0)
            let v11 := v10
            return_value__Evm_Sol_bool__261f3a707fad09c8(0, v11)
          }
          case 599290589 {
            let v12 := _t0__t1__t2__decode_decode__Sol_Address_Address_u256_SolDecoder_CallData___da321e92055b22cd(v3)
            let v13 := v0
            let v14 := recv_Erc20_TransferFrom_0_2(v12, 0, v13, 0)
            let v15 := v14
            return_value__Evm_Sol_bool__261f3a707fad09c8(0, v15)
          }
          case 1889567281 {
            let v16 := _t0__decode_decode__Sol_Address_SolDecoder_CallData___c3cd70daebc6e8b9(v3)
            let v17 := v0
            let v18 := recv_Erc20_BalanceOf_0_3(v16, v17)
            let v19 := v18
            return_value__Evm_Sol_u256__fe091c64bccbbbf1(0, v19)
          }
          case 3714247998 {
            let v20 := _t0__t1__decode_decode__Sol_Address_Address_SolDecoder_CallData___7ed19c3f9fd70917(v3)
            let v21 := v0
            let v22 := recv_Erc20_Allowance_0_4(v20, v21)
            let v23 := v22
            return_value__Evm_Sol_u256__fe091c64bccbbbf1(0, v23)
          }
          case 404098525 {
            ___decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(v3)
            let v24 := v0
            let v25 := recv_Erc20_TotalSupply_0_5(0, v24)
            let v26 := v25
            return_value__Evm_Sol_u256__fe091c64bccbbbf1(0, v26)
          }
          case 117300739 {
            ___decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(v3)
            let v27 := recv_Erc20_Name_0_6(0)
            return_value__Evm_Sol_String_32___fce5fd9d073f47ee(0, v27)
          }
          case 2514000705 {
            ___decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(v3)
            let v28 := recv_Erc20_Symbol_0_7(0)
            return_value__Evm_Sol_String_8___90b3a09bdf47bf15(0, v28)
          }
          case 826074471 {
            ___decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(v3)
            let v29 := recv_Erc20_Decimals_0_8(0)
            return_value__Evm_Sol_u8__d483d38efd15a73d(0, v29)
          }
          case 1086394137 {
            let v30 := _t0__t1__decode_decode__Sol_Address_u256_SolDecoder_CallData___25b1373fd1f61181(v3)
            let v31 := v0
            let v32 := v1
            let v33 := recv_Erc20Extended_Mint_1_0(v30, 0, v31, 0, v32)
            let v34 := v33
            return_value__Evm_Sol_bool__261f3a707fad09c8(0, v34)
          }
          case 1117154408 {
            let v35 := _t0__decode_decode__Sol_u256_SolDecoder_CallData___51fc2f6931ec5edc(v3)
            let v36 := v0
            let v37 := recv_Erc20Extended_Burn_1_1(v35, 0, v36, 0)
            let v38 := v37
            return_value__Evm_Sol_bool__261f3a707fad09c8(0, v38)
          }
          case 2043438992 {
            let v39 := _t0__t1__decode_decode__Sol_Address_u256_SolDecoder_CallData___25b1373fd1f61181(v3)
            let v40 := v0
            let v41 := recv_Erc20Extended_BurnFrom_1_2(v39, 0, v40, 0)
            let v42 := v41
            return_value__Evm_Sol_bool__261f3a707fad09c8(0, v42)
          }
          case 961581905 {
            let v43 := _t0__t1__decode_decode__Sol_Address_u256_SolDecoder_CallData___25b1373fd1f61181(v3)
            let v44 := v0
            let v45 := recv_Erc20Extended_IncreaseAllowance_1_3(v43, 0, v44, 0)
            let v46 := v45
            return_value__Evm_Sol_bool__261f3a707fad09c8(0, v46)
          }
          case 2757214935 {
            let v47 := _t0__t1__decode_decode__Sol_Address_u256_SolDecoder_CallData___25b1373fd1f61181(v3)
            let v48 := v0
            let v49 := recv_Erc20Extended_DecreaseAllowance_1_4(v47, 0, v48, 0)
            let v50 := v49
            return_value__Evm_Sol_bool__261f3a707fad09c8(0, v50)
          }
          default {
            evm_contracthost_abort(0)
          }
      }
      function runtime_decoder__Evm_Sol__2533f5c49b57a682(self) -> ret {
        let v0 := evm_contracthost_input(self)
        let v1 := sol_abi_decoder_with_base__CallData__b9ab8dc8a4b2f9e(v0, 4)
        ret := v1
        leave
      }
      function runtime_selector__Evm_Sol__2533f5c49b57a682(self) -> ret {
        let v0 := evm_contracthost_input(self)
        let v1 := calldata_byteinput_len(v0)
        let v2 := lt(v1, 4)
        if v2 {
          evm_contracthost_abort(self)
        }
        let v3 := calldata_byteinput_word_at(v0, 0)
        let v4 := sol_abi_selector_from_prefix(v3)
        ret := v4
        leave
      }
      function sol_abi_decoder_with_base__CallData__b9ab8dc8a4b2f9e(input, base) -> ret {
        let v0 := soldecoder_i__with_base__CallData__b9ab8dc8a4b2f9e(input, base)
        ret := v0
        leave
      }
      function sol_abi_encoder_new() -> ret {
        let v0 := solencoder_new()
        ret := v0
        leave
      }
      function sol_abi_selector_from_prefix(prefix) -> ret {
        let v0 := shr(224, prefix)
        ret := v0
        leave
      }
      function soldecoder_i__abidecoder_read_word__CallData__b9ab8dc8a4b2f9e(self) -> ret {
        let v0 := calldata_byteinput_len(self)
        let v1 := mload(add(self, 32))
        let v2 := add(v1, 32)
        let v3 := mload(add(self, 32))
        let v4 := or(lt(v2, v3), gt(v2, v0))
        if v4 {
          revert(0, 0)
        }
        let v5 := mload(add(self, 32))
        let v6 := calldata_byteinput_word_at(self, v5)
        mstore(add(self, 32), v2)
        ret := v6
        leave
      }
      function soldecoder_i__with_base__CallData__b9ab8dc8a4b2f9e(input, base) -> ret {
        let v0 := cursor_i__new__MemoryBytes__b48f82585f3ed728(input)
        let v1 := cursor_i__fork_mem__CallData__b9ab8dc8a4b2f9e(v0, base)
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 96))
        let v3 := v1
        mstore(v2, mload(v3))
        mstore(add(v2, 32), mload(add(v3, 32)))
        mstore(add(v2, 64), base)
        let v4 := v2
        ret := v4
        leave
      }
      function solencoder_abiencoder_finish(self) -> ret {
        let v0 := mload(self)
        let v1 := mload(add(self, 64))
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 64))
        mstore(v2, v0)
        mstore(add(v2, 32), sub(v1, v0))
        ret := v2
        leave
      }
      function solencoder_abiencoder_reserve_head(self, bytes) -> ret {
        solencoder_ensure_init_mem(self, bytes)
        let v0 := mload(self)
        ret := v0
        leave
      }
      function solencoder_abiencoder_write_word(self, v) {
        let v0 := mload(add(self, 32))
        mstore(v0, v)
        mstore(add(self, 32), add(v0, 32))
        leave
      }
      function solencoder_ensure_init_mem(self, bytes) {
        let v0 := mload(self)
        let v1 := eq(v0, 0)
        if v1 {
          let v2 := alloc(bytes)
          mstore(self, v2)
          mstore(add(self, 32), v2)
          mstore(add(self, 64), add(v2, bytes))
        }
        leave
      }
      function solencoder_new() -> ret {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 96))
        mstore(v0, 0)
        mstore(add(v0, 32), 0)
        mstore(add(v0, 64), 0)
        let v1 := v0
        ret := v1
        leave
      }
      function spend_allowance(owner, spender, amount, store) {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 64))
        let v1 := owner
        mstore(v0, mload(v1))
        let v2 := spender
        mstore(add(v0, 32), mload(v2))
        let v3 := storagemap_k__v__get_stor___Address__Address__u256__380d6b10c386a4ee(add(store, 2), v0)
        assert(iszero(lt(v3, amount)))
        let v4 := mload(0x40)
        if iszero(v4) {
          v4 := 0x80
        }
        mstore(0x40, add(v4, 64))
        let v5 := owner
        mstore(v4, mload(v5))
        let v6 := spender
        mstore(add(v4, 32), mload(v6))
        storagemap_k__v__set_stor___Address__Address__u256__380d6b10c386a4ee(add(store, 2), v4, sub(v3, amount))
        leave
      }
      function stor_ptr__Evm_AccessControl__9eae422fa78e0dfe(self, slot) -> ret {
        ret := slot
        leave
      }
      function stor_ptr__Evm_TokenStore__f6aa99d6ecaccf30(self, slot) -> ret {
        ret := slot
        leave
      }
      function storagemap_k__v__get_stor__Address_u256__cdd966cb4c9acb9d(self, key) -> ret {
        let v0 := storagemap_k__v__storage_slot_stor__Address_u256__cdd966cb4c9acb9d(self, key)
        let v1 := sload(v0)
        let v2 := u256_wordrepr_from_word(v1)
        ret := v2
        leave
      }
      function storagemap_k__v__get_stor___Address__Address__u256__380d6b10c386a4ee(self, key) -> ret {
        let v0 := storagemap_k__v__storage_slot_stor___Address__Address__u256__380d6b10c386a4ee(self, key)
        let v1 := sload(v0)
        let v2 := u256_wordrepr_from_word(v1)
        ret := v2
        leave
      }
      function storagemap_k__v__get_stor___u256__Address__bool__ac1f217814dd9c46(self, key) -> ret {
        let v0 := storagemap_k__v__storage_slot_stor___u256__Address__bool__ac1f217814dd9c46(self, key)
        let v1 := sload(v0)
        let v2 := bool_wordrepr_from_word(v1)
        ret := v2
        leave
      }
      function storagemap_k__v__set_stor__Address_u256__cdd966cb4c9acb9d(self, key, value) {
        let v0 := storagemap_k__v__storage_slot_stor__Address_u256__cdd966cb4c9acb9d(self, key)
        let v1 := u256_wordrepr_to_word(value)
        sstore(v0, v1)
        leave
      }
      function storagemap_k__v__set_stor___Address__Address__u256__380d6b10c386a4ee(self, key, value) {
        let v0 := storagemap_k__v__storage_slot_stor___Address__Address__u256__380d6b10c386a4ee(self, key)
        let v1 := u256_wordrepr_to_word(value)
        sstore(v0, v1)
        leave
      }
      function storagemap_k__v__storage_slot_stor__Address_u256__cdd966cb4c9acb9d(self, key) -> ret {
        let v0 := mload(64)
        let v1 := address_storagekey_write_key(v0, key)
        let v2 := self
        mstore(add(v0, v1), v2)
        let v3 := keccak256(v0, add(v1, 32))
        ret := v3
        leave
      }
      function storagemap_k__v__storage_slot_stor___Address__Address__u256__380d6b10c386a4ee(self, key) -> ret {
        let v0 := mload(64)
        let v1 := _a__b__storagekey_write_key__Address_Address__397b9a625a435b6f(v0, key)
        let v2 := self
        mstore(add(v0, v1), v2)
        let v3 := keccak256(v0, add(v1, 32))
        ret := v3
        leave
      }
      function storagemap_k__v__storage_slot_stor___u256__Address__bool__ac1f217814dd9c46(self, key) -> ret {
        let v0 := mload(64)
        let v1 := _a__b__storagekey_write_key__u256_Address__1ae3ad2a1b729a8b(v0, key)
        let v2 := self
        mstore(add(v0, v1), v2)
        let v3 := keccak256(v0, add(v1, 32))
        ret := v3
        leave
      }
      function string_const_n__usize__encode_encode__Sol_32_SolEncoder__85bcb27fa2f25e8f(self, e) {
        let v0 := self
        solencoder_abiencoder_write_word(e, v0)
        leave
      }
      function transfer(from, to, amount, store, log) {
        let v0 := address_zero()
        assert(iszero(eq(from, v0)))
        let v1 := address_zero()
        assert(iszero(eq(to, v1)))
        let v2 := storagemap_k__v__get_stor__Address_u256__cdd966cb4c9acb9d(add(store, 1), from)
        assert(iszero(lt(v2, amount)))
        storagemap_k__v__set_stor__Address_u256__cdd966cb4c9acb9d(add(store, 1), from, sub(v2, amount))
        let v3 := storagemap_k__v__get_stor__Address_u256__cdd966cb4c9acb9d(add(store, 1), to)
        storagemap_k__v__set_stor__Address_u256__cdd966cb4c9acb9d(add(store, 1), to, add(v3, amount))
        let v4 := mload(0x40)
        if iszero(v4) {
          v4 := 0x80
        }
        mstore(0x40, add(v4, 96))
        let v5 := from
        mstore(v4, mload(v5))
        let v6 := to
        mstore(add(v4, 32), mload(v6))
        mstore(add(v4, 64), amount)
        emit__log__Log_TransferEvent__41b584f23318b0be(log, v4)
        leave
      }
      function u256_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d) -> ret {
        let v0 := soldecoder_i__abidecoder_read_word__CallData__b9ab8dc8a4b2f9e(d)
        ret := v0
        leave
      }
      function u256_encode_encode__Sol_SolEncoder__dce63ad1a1fe4ae2(self, e) {
        solencoder_abiencoder_write_word(e, self)
        leave
      }
      function u256_storagekey_write_key(ptr, self) -> ret {
        mstore(ptr, self)
        ret := 32
        leave
      }
      function u256_wordrepr_from_word(word) -> ret {
        ret := word
        leave
      }
      function u256_wordrepr_to_word(self) -> ret {
        ret := self
        leave
      }
      function u8_encode_encode__Sol_SolEncoder__dce63ad1a1fe4ae2(self, e) {
        let v0 := self
        solencoder_abiencoder_write_word(e, v0)
        leave
      }
      runtime()
      return(0, 0)
    }
  }
}
