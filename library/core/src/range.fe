use ingot::seq::{Seq, Const, Dyn}

/// A range with compile-time known length: `start..start+N`
pub struct Range<const N: usize> {
    pub start: usize,
}

/// A range with runtime-determined length: `start..end`
pub struct DynRange {
    pub start: usize,
    pub end: usize,
}

impl<const N: usize> Range<N> {
    pub fn new(start: usize) -> Self {
        Range { start }
    }
}

impl DynRange {
    pub fn new(start: usize, end: usize) -> Self {
        DynRange { start, end }
    }
}

/// Seq implementation for const-length Range.
/// Enables loop unrolling when iterating over `0..N` where N is const.
impl<const N: usize> Seq<usize> for Range<N> {
    type Len = Const<N>

    fn len(self) -> Const<N> {
        Const {}
    }

    fn get(self, i: usize) -> usize {
        self.start + i
    }
}

/// Seq implementation for dynamic-length Range.
impl Seq<usize> for DynRange {
    type Len = Dyn

    fn len(self) -> Dyn {
        Dyn { value: self.end - self.start }
    }

    fn get(self, i: usize) -> usize {
        self.start + i
    }
}
