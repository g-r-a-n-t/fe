use super::intrinsic

pub trait AsBytes {
    const N: usize
    const fn as_bytes(self) -> [u8; Self::N]
}

impl<const LEN: usize> AsBytes for [u8; LEN] {
    const N: usize = LEN
    const fn as_bytes(self) -> [u8; Self::N] { self }
}

impl<const LEN: usize> AsBytes for String<LEN> {
    const N: usize = LEN
    const fn as_bytes(self) -> [u8; Self::N] { intrinsic::__as_bytes(self) }
}

impl AsBytes for u256 {
    const N: usize = 32
    const fn as_bytes(self) -> [u8; Self::N] { intrinsic::__as_bytes(self) }
}

impl<T0, T1> AsBytes for (T0, T1)
    where T0: AsBytes,
          T1: AsBytes
{
    const N: usize = T0::N + T1::N
    const fn as_bytes(self) -> [u8; Self::N] {
        let a: [u8; T0::N] = self.0.as_bytes()
        let b: [u8; T1::N] = self.1.as_bytes()
        let out: [u8; Self::N] = intrinsic::__as_bytes((a, b))
        out
    }
}

impl<T0, T1, T2> AsBytes for (T0, T1, T2)
    where T0: AsBytes,
          T1: AsBytes,
          T2: AsBytes
{
    const N: usize = T0::N + T1::N + T2::N
    const fn as_bytes(self) -> [u8; Self::N] {
        let a: [u8; T0::N] = self.0.as_bytes()
        let b: [u8; T1::N] = self.1.as_bytes()
        let c: [u8; T2::N] = self.2.as_bytes()
        let out: [u8; Self::N] = intrinsic::__as_bytes((a, b, c))
        out
    }
}

impl<T0, T1, T2, T3> AsBytes for (T0, T1, T2, T3)
    where T0: AsBytes,
          T1: AsBytes,
          T2: AsBytes,
          T3: AsBytes
{
    const N: usize = T0::N + T1::N + T2::N + T3::N
    const fn as_bytes(self) -> [u8; Self::N] {
        let a: [u8; T0::N] = self.0.as_bytes()
        let b: [u8; T1::N] = self.1.as_bytes()
        let c: [u8; T2::N] = self.2.as_bytes()
        let d: [u8; T3::N] = self.3.as_bytes()
        let out: [u8; Self::N] = intrinsic::__as_bytes((a, b, c, d))
        out
    }
}

pub const fn keccak<T: AsBytes>(x: T) -> u256 {
    let bytes: [u8; T::N] = x.as_bytes()
    intrinsic::__keccak256(bytes)
}
