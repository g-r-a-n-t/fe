// Test generic struct with multiple MsgVariant impls used in recv block

struct GenericMsg<T> {
    pub value: T,
}

impl<T> core::abi::Encode<std::abi::Sol> for GenericMsg<T>
    where T: core::abi::Encode<std::abi::Sol>
{
    fn encode<E: core::abi::AbiEncoder<std::abi::Sol>>(self, mut _ e: E) {
        let Self { value } = self
        value.encode(e)
    }
}

impl<T> core::abi::Decode<std::abi::Sol> for GenericMsg<T>
    where T: core::abi::Decode<std::abi::Sol>
{
    fn decode<D: core::abi::AbiDecoder<std::abi::Sol>>(mut _ d: D) -> Self {
        let value = T::decode(d)
        Self { value }
    }
}

impl core::message::MsgVariant<std::abi::Sol> for GenericMsg<u8> {
    const SELECTOR: u32 = 0x01
    type Return = u8
}

impl core::message::MsgVariant<std::abi::Sol> for GenericMsg<u16> {
    const SELECTOR: u32 = 0x02
    type Return = u16
}

impl core::message::MsgVariant<std::abi::Sol> for GenericMsg<u64> {
    const SELECTOR: u32 = 0x03
    type Return = u64
}

pub contract GenericRecvContract {
    data: u64,

    recv {
        GenericMsg<u8> { value } -> u8 uses () {
            value
        }
        GenericMsg<u16> { value } -> u16 uses () {
            value
        }
        GenericMsg<u64> { value } -> u64 uses (data) {
            data + value
        }
    }
}
