use core::num::*

// Masks used to truncate a 256-bit word down to the requested primitive width.
const U8_MASK: u256 = 0xff
const U16_MASK: u256 = 0xffff
const U32_MASK: u256 = 0xffffffff
const U64_MASK: u256 = 0xffffffffffffffff
const U128_MASK: u256 = 0xffffffffffffffffffffffffffffffff
const U256_MASK: u256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

// Sign bits used when performing two's-complement sign extension per width.
const I8_SIGN_BIT: u256 = 0x80
const I16_SIGN_BIT: u256 = 0x8000
const I32_SIGN_BIT: u256 = 0x80000000
const I64_SIGN_BIT: u256 = 0x8000000000000000
const I128_SIGN_BIT: u256 = 0x80000000000000000000000000000000
const I256_SIGN_BIT: u256 = 0x8000000000000000000000000000000000000000000000000000000000000000

/// A value that can round-trip through an EVM word (`u256`).
///
/// This replaces the older `LoadableScalar` / `StorableScalar` split with a
/// single trait that supports both primitives and user-defined newtypes.
pub trait WordRepr {
    fn from_word(word: u256) -> Self
    fn to_word(self) -> u256
}

impl WordRepr for u8 {
    fn from_word(word: u256) -> Self {
        (word & U8_MASK).downcast_unchecked()
    }
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl WordRepr for u16 {
    fn from_word(word: u256) -> Self {
        (word & U16_MASK).downcast_unchecked()
    }
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl WordRepr for u32 {
    fn from_word(word: u256) -> Self {
        (word & U32_MASK).downcast_unchecked()
    }
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl WordRepr for u64 {
    fn from_word(word: u256) -> Self {
        (word & U64_MASK).downcast_unchecked()
    }
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl WordRepr for u128 {
    fn from_word(word: u256) -> Self {
        (word & U128_MASK).downcast_unchecked()
    }
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl WordRepr for u256 {
    fn from_word(word: u256) -> Self {
        word
    }
    fn to_word(self) -> u256 {
        self
    }
}

impl WordRepr for usize {
    fn from_word(word: u256) -> Self {
        word as usize
    }
    fn to_word(self) -> u256 {
        self as u256
    }
}

impl WordRepr for bool {
    fn from_word(word: u256) -> Self {
        word != 0
    }
    fn to_word(self) -> u256 {
        if self { 1 } else { 0 }
    }
}

impl WordRepr for i8 {
    fn from_word(word: u256) -> Self {
        sign_extend(word, U8_MASK, I8_SIGN_BIT).downcast_unchecked()
    }
    fn to_word(self) -> u256 {
        self.downcast_unchecked()
    }
}

impl WordRepr for i16 {
    fn from_word(word: u256) -> Self {
        sign_extend(word, U16_MASK, I16_SIGN_BIT).downcast_unchecked()
    }
    fn to_word(self) -> u256 {
        self.downcast_unchecked()
    }
}

impl WordRepr for i32 {
    fn from_word(word: u256) -> Self {
        sign_extend(word, U32_MASK, I32_SIGN_BIT).downcast_unchecked()
    }
    fn to_word(self) -> u256 {
        self.downcast_unchecked()
    }
}

impl WordRepr for i64 {
    fn from_word(word: u256) -> Self {
        sign_extend(word, U64_MASK, I64_SIGN_BIT).downcast_unchecked()
    }
    fn to_word(self) -> u256 {
        self.downcast_unchecked()
    }
}

impl WordRepr for i128 {
    fn from_word(word: u256) -> Self {
        sign_extend(word, U128_MASK, I128_SIGN_BIT).downcast_unchecked()
    }
    fn to_word(self) -> u256 {
        self.downcast_unchecked()
    }
}

impl WordRepr for i256 {
    fn from_word(word: u256) -> Self {
        sign_extend(word, U256_MASK, I256_SIGN_BIT).downcast_unchecked()
    }
    fn to_word(self) -> u256 {
        self.downcast_unchecked()
    }
}

impl WordRepr for isize {
    fn from_word(word: u256) -> Self {
        word.downcast_unchecked()
    }
    fn to_word(self) -> u256 {
        self.downcast_unchecked()
    }
}

/// Performs two's-complement sign extension within the provided mask/sign bit.
fn sign_extend(word: u256, _ mask: u256, _ sign_bit: u256) -> u256 {
    let value = word & mask
    if value & sign_bit != 0 {
        value | (!mask)
    } else {
        value
    }
}
