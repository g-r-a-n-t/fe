use std::evm::{Address, Ctx, StorageMap, assert}
use std::evm::effects::Log
use std::abi::sol

// roles
const MINTER: u256 = 1
const BURNER: u256 = 2

// StorageMap salts (type-level discriminators)
const BALANCES_SALT: u256 = 0
const ALLOWANCES_SALT: u256 = 1
const ROLES_SALT: u256 = 2

pub contract CoolCoin uses (mut ctx: Ctx, mut log: Log) {
    // Storage fields. These act as effects within the contract.
    mut store: TokenStore,
    mut auth: AccessControl,

    // Initialize the token with name, symbol, decimals, and initial supply
    init(initial_supply: u256, owner: Address)
      uses (mut store, mut auth, mut ctx, mut log)
    {
        auth.grant(role: MINTER, to: owner)
        auth.grant(role: BURNER, to: owner)

        if initial_supply > 0 {
            mint(to: owner, amount: initial_supply)
        }
    }

    recv Erc20 {
        Transfer { to, amount } -> bool uses (ctx, mut store, mut log) {
            transfer(from: ctx.caller(), to, amount)
            true
        }

        Approve { spender, amount } -> bool uses (ctx, mut store, mut log) {
            approve(owner: ctx.caller(), spender, amount)
            true
        }

        TransferFrom { from, to, amount } -> bool uses (ctx, mut store, mut log) {
            spend_allowance(owner: from, spender: ctx.caller(), amount)
            transfer(from, to, amount)
            true
        }

        BalanceOf { account } -> u256 uses store {
            store.balances.get(account)
        }

        Allowance { owner, spender } -> u256 uses (store) {
            store.allowances.get((owner, spender))
        }

        TotalSupply {} -> u256 uses store {
            store.total_supply
        }

        Name {} -> String<32> { "CoolCoin" }
        Symbol {} -> String<8> { "COOL" }
        Decimals {} -> u8 { 18 }
    }

    // Extended functionality (minting and burning)
    recv Erc20Extended {
        Mint { to, amount } -> bool uses (ctx, mut store, mut log, auth) {
            auth.require(role: MINTER)
            mint(to, amount)
            true
        }

        // Burns tokens from caller's balance
        Burn { amount } -> bool uses (ctx, mut store, mut log) {
            burn(from: ctx.caller(), amount)
            true
        }

        // Burns tokens from an account using allowance (requires BURNER or allowance)
        BurnFrom { from, amount } -> bool uses (ctx, mut store, mut log) {
            spend_allowance(owner: from, spender: ctx.caller(), amount)
            burn(from, amount)
            true
        }

        IncreaseAllowance { spender, added_value } -> bool
        uses (ctx, mut store, mut log)
        {
            let owner = ctx.caller()
            let current = store.allowances.get((owner, spender))
            approve(owner, spender, amount: current + added_value)
            true
        }

        DecreaseAllowance { spender, subtracted_value } -> bool
        uses (ctx, mut store, mut log) {
            let owner = ctx.caller()
            let current = store.allowances.get((owner, spender))
            assert(current >= subtracted_value)
            approve(owner, spender, amount: current - subtracted_value)
            true
        }
    }
}

fn transfer(from: Address, to: Address, amount: u256)
    uses (mut store: TokenStore, mut log: Log)
{
    assert(from != Address::zero())
    assert(to != Address::zero())

    let from_balance = store.balances.get(from)
    assert(from_balance >= amount)

    store.balances.set(from, from_balance - amount)
    store.balances.set(to, store.balances.get(to) + amount)

    log.emit(TransferEvent { from, to, value: amount })
}

fn mint(to: Address, amount: u256)
    uses (mut store: TokenStore, mut log: Log)
{
    assert(to != Address::zero())

    store.total_supply += amount
    store.balances.set(to, store.balances.get(to) + amount)

    log.emit(TransferEvent { from: Address::zero(), to, value: amount })
}

fn burn(from: Address, amount: u256)
    uses (mut store: TokenStore, mut log: Log)
{
    assert(from != Address::zero())

    let from_balance = store.balances.get(from)
    assert(from_balance >= amount)

    store.balances.set(from, from_balance - amount)
    store.total_supply -= amount

    log.emit(TransferEvent { from, to: Address::zero(), value: amount })
}

fn approve(owner: Address, spender: Address, amount: u256)
    uses (mut store: TokenStore, mut log: Log)
{
    assert(owner != Address::zero())
    assert(spender != Address::zero())

    store.allowances.set((owner, spender), amount)

    log.emit(ApprovalEvent { owner, spender, value: amount })
}

// Internal function to spend allowance
fn spend_allowance(owner: Address, spender: Address, amount: u256)
    uses (mut store: TokenStore)
{
    let current = store.allowances.get((owner, spender))
    // if current != u256::MAX { // TODO: define ::MAX constants
        assert(current >= amount)
        store.allowances.set((owner, spender), current - amount)
    // }
}

struct TokenStore {
    total_supply: u256,
    balances: StorageMap<Address, u256, BALANCES_SALT>,
    allowances: StorageMap<(Address, Address), u256, ALLOWANCES_SALT>,
}

pub struct AccessControl {
    roles: StorageMap<(u256, Address), bool, ROLES_SALT>,
}

impl AccessControl {
    pub fn has_role(self, role: u256, account: Address) -> bool {
        self.roles.get((role, account))
    }

    pub fn require(self, role: u256) uses (ctx: Ctx) {
        assert(self.roles.get((role, ctx.caller())) == true)
    }

    pub fn grant(mut self, role: u256, to: Address) {
        self.roles.set((role, to), true)
    }

    pub fn revoke(mut self, role: u256, from: Address) {
        self.roles.set((role, from), false)
    }
}

// ERC20 standard message types
msg Erc20 {
    #[selector = sol("name()")]
    Name -> String<32>,

    #[selector = sol("symbol()")]
    Symbol -> String<8>,

    #[selector = sol("decimals()")]
    Decimals -> u8,

    #[selector = sol("totalSupply()")]
    TotalSupply -> u256,

    #[selector = sol("balanceOf(address)")]
    BalanceOf { account: Address } -> u256,

    #[selector = sol("allowance(address,address)")]
    Allowance { owner: Address, spender: Address } -> u256,

    #[selector = sol("transfer(address,uint256)")]
    Transfer { to: Address, amount: u256 } -> bool,

    #[selector = sol("approve(address,uint256)")]
    Approve { spender: Address, amount: u256 } -> bool,

    #[selector = sol("transferFrom(address,address,uint256)")]
    TransferFrom { from: Address, to: Address, amount: u256 } -> bool,
}

// Extended ERC20 message types (minting, burning, allowance helpers)
msg Erc20Extended {
    #[selector = sol("mint(address,uint256)")]
    Mint { to: Address, amount: u256 } -> bool,

    #[selector = sol("burn(uint256)")]
    Burn { amount: u256 } -> bool,

    #[selector = sol("burnFrom(address,uint256)")]
    BurnFrom { from: Address, amount: u256 } -> bool,

    #[selector = sol("increaseAllowance(address,uint256)")]
    IncreaseAllowance { spender: Address, added_value: u256 } -> bool,

    #[selector = sol("decreaseAllowance(address,uint256)")]
    DecreaseAllowance { spender: Address, subtracted_value: u256 } -> bool,
}

// ERC20 events
struct TransferEvent {
    #[indexed]
    from: Address,
    #[indexed]
    to: Address,
    value: u256,
}

struct ApprovalEvent {
    #[indexed]
    owner: Address,
    #[indexed]
    spender: Address,
    value: u256,
}
