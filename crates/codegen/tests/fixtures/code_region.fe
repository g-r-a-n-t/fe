use std::evm::{Create, Evm, RawMem, RawOps}

#[contract_init(Foo)]
fn init() uses (mut evm: Evm) {
    { // create child contract
        let len = evm.code_region_len(child_init)
        let offset = evm.code_region_offset(child_init)
        let dest = with (RawMem = evm) { allocate(bytes: len) }
        evm.codecopy(dest, offset, len)
        evm.create2(value: 0, offset, len: len, salt: 0x1234)
    }

    let len = evm.code_region_len(runtime)
    let offset = evm.code_region_offset(runtime)
    let dest = with (RawMem = evm) { allocate(bytes: len) }
    evm.codecopy(dest, offset, len)
    evm.return_data(dest, len)
}

#[contract_runtime(Foo)]
fn runtime() uses (mut evm: Evm) {
    with (RawOps = evm) {
        match read_selector() {
            0x12345678 => { transfer() }
            0x23456789 => { balance() }
            _ => {}
        }
    }
    evm.return_data(0,0)
}

#[contract_init(Child)]
fn child_init() uses (mut evm: Evm) {
    let len = evm.code_region_len(child_runtime)
    let offset = evm.code_region_offset(child_runtime)
    evm.codecopy(dest: 0, offset, len)
    evm.return_data(0, len)
}

#[contract_runtime(Child)]
fn child_runtime() uses (mut evm: Evm) {
    evm.calldatacopy(dest: 0, offset: 0, len: 4)
    evm.return_data(0, 4)
}

fn allocate(bytes: u256) -> u256 uses (mut mem: RawMem) {
    let mut ptr = mem.mload(0x40)
    if ptr == 0 {
        ptr = 0x60
    }
    mem.mstore(0x40, ptr + bytes)
    ptr
}

fn balance() uses (ops: RawOps) {
    ops.return_data(0, 0)
}

fn transfer() uses (ops: RawOps) {
    ops.return_data(0, 0)
}

pub fn read_selector() -> u256 uses (ops: RawOps) {
    let word = ops.calldataload(0)
    // Shift right by 224 bits to keep only the first four bytes.
    word >> 224
}
