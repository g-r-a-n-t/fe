---
source: crates/codegen/tests/yul.rs
expression: output
input_file: tests/fixtures/erc20_low_level.fe
---
object "Erc20Contract" {
  code {
    function address_zero() -> ret {
      let v0 := mload(0x40)
      if iszero(v0) {
        v0 := 0x80
      }
      mstore(0x40, add(v0, 32))
      mstore(v0, 0)
      ret := v0
      leave
    }
    function do_init(erc20, ctx, ops) {
      let v0 := mload(0x40)
      if iszero(v0) {
        v0 := 0x80
      }
      mstore(0x40, add(v0, 32))
      let v1 := caller()
      mstore(v0, v1)
      erc20_set_owner_once_stor(erc20, v0, ops)
      leave
    }
    function erc20_set_owner_once_stor(self, owner, ops) {
      let v0 := address_zero()
      let v1 := iszero(eq(add(self, 3), v0))
      if v1 {
        revert(0, 0)
      }
      let v2 := owner
      sstore(add(self, 3), mload(v2))
      leave
    }
    function init() {
      let v0 := stor_ptr__Evm_Erc20__c294a0aeae425afd(0, 0)
      let v1 := v0
      do_init(v1, 0, 0)
      let v2 := datasize("Erc20Contract_deployed")
      let v3 := dataoffset("Erc20Contract_deployed")
      codecopy(0, v3, v2)
      return(0, v2)
    }
    function stor_ptr__Evm_Erc20__c294a0aeae425afd(self, slot) -> ret {
      ret := slot
      leave
    }
    init()
  }

  object "Erc20Contract_deployed" {
    code {
      function _a__b__storagekey_write_key__Address_Address__397b9a625a435b6f(ptr, self) -> ret {
        let v0 := self
        let v1 := add(self, 32)
        let v2 := address_storagekey_write_key(ptr, v0)
        let v3 := address_storagekey_write_key(add(ptr, v2), v1)
        ret := add(v2, v3)
        leave
      }
      function abi_encode_string(word, len, ops) {
        mstore(0, 32)
        mstore(32, len)
        mstore(64, word)
        return(0, 96)
      }
      function abi_encode_u256(value, ops) {
        mstore(0, value)
        return(0, 32)
      }
      function address_storagekey_write_key(ptr, self) -> ret {
        let v0 := mload(self)
        let v1 := u256_storagekey_write_key(ptr, v0)
        ret := v1
        leave
      }
      function allowance(owner, spender, erc20) -> ret {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 64))
        let v1 := owner
        mstore(v0, mload(v1))
        let v2 := spender
        mstore(add(v0, 32), mload(v2))
        let v3 := storagemap_k__v__get_stor___Address__Address__u256__380d6b10c386a4ee(add(erc20, 1), v0)
        ret := v3
        leave
      }
      function approve(spender, amount, erc20, ctx) -> ret {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 32))
        let v1 := caller()
        mstore(v0, v1)
        erc20_approve_stor(erc20, v0, spender, amount)
        ret := 1
        leave
      }
      function balance_of(addr, erc20) -> ret {
        let v0 := storagemap_k__v__get_stor__Address_u256__cdd966cb4c9acb9d(erc20, addr)
        ret := v0
        leave
      }
      function erc20_allowance_stor(self, owner, spender) -> ret {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 64))
        let v1 := owner
        mstore(v0, mload(v1))
        let v2 := spender
        mstore(add(v0, 32), mload(v2))
        let v3 := storagemap_k__v__get_stor___Address__Address__u256__380d6b10c386a4ee(add(self, 1), v0)
        ret := v3
        leave
      }
      function erc20_approve_stor(self, owner, spender, value) {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 64))
        let v1 := owner
        mstore(v0, mload(v1))
        let v2 := spender
        mstore(add(v0, 32), mload(v2))
        storagemap_k__v__set_stor___Address__Address__u256__380d6b10c386a4ee(add(self, 1), v0, value)
        leave
      }
      function erc20_balance_of_stor(self, addr) -> ret {
        let v0 := storagemap_k__v__get_stor__Address_u256__cdd966cb4c9acb9d(self, addr)
        ret := v0
        leave
      }
      function erc20_mint_stor(self, to, amount, ctx, ops) {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 32))
        let v1 := caller()
        mstore(v0, v1)
        let v2 := iszero(eq(v0, add(self, 3)))
        if v2 {
          revert(0, 0)
        }
        let v3 := erc20_balance_of_stor(self, to)
        storagemap_k__v__set_stor__Address_u256__cdd966cb4c9acb9d(self, to, add(v3, amount))
        let v4 := sload(add(self, 2))
        sstore(add(self, 2), add(v4, amount))
        leave
      }
      function erc20_transfer_from_stor(self, owner, to, amount, ctx, ops) {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 32))
        let v1 := caller()
        mstore(v0, v1)
        let v2 := erc20_allowance_stor(self, owner, v0)
        let v3 := lt(v2, amount)
        if v3 {
          revert(0, 0)
        }
        erc20_transfer_stor(self, owner, to, amount, ops)
        let v4 := mload(0x40)
        if iszero(v4) {
          v4 := 0x80
        }
        mstore(0x40, add(v4, 64))
        let v5 := owner
        mstore(v4, mload(v5))
        let v6 := v0
        mstore(add(v4, 32), mload(v6))
        storagemap_k__v__set_stor___Address__Address__u256__380d6b10c386a4ee(add(self, 1), v4, sub(v2, amount))
        leave
      }
      function erc20_transfer_stor(self, from, to, amount, ops) {
        let v0 := erc20_balance_of_stor(self, from)
        let v1 := lt(v0, amount)
        if v1 {
          revert(0, 0)
        }
        let v2 := erc20_balance_of_stor(self, to)
        storagemap_k__v__set_stor__Address_u256__cdd966cb4c9acb9d(self, from, sub(v0, amount))
        storagemap_k__v__set_stor__Address_u256__cdd966cb4c9acb9d(self, to, add(v2, amount))
        leave
      }
      function mint(to, amount, erc20, ctx, ops) -> ret {
        erc20_mint_stor(erc20, to, amount, ctx, ops)
        ret := 1
        leave
      }
      function runtime() {
        let v0 := stor_ptr__Evm_Erc20__c294a0aeae425afd(0, 0)
        let v1 := calldataload(0)
        let v2 := shr(224, v1)
        let v3 := v0
        switch v2
          case 1889567281 {
            let v4 := calldataload(4)
            let v5 := mload(0x40)
            if iszero(v5) {
              v5 := 0x80
            }
            mstore(0x40, add(v5, 32))
            mstore(v5, v4)
            let v6 := v5
            let v7 := balance_of(v6, v3)
            abi_encode_u256(v7, 0)
          }
          case 3714247998 {
            let v8 := calldataload(4)
            let v9 := mload(0x40)
            if iszero(v9) {
              v9 := 0x80
            }
            mstore(0x40, add(v9, 32))
            mstore(v9, v8)
            let v10 := v9
            let v11 := calldataload(36)
            let v12 := mload(0x40)
            if iszero(v12) {
              v12 := 0x80
            }
            mstore(0x40, add(v12, 32))
            mstore(v12, v11)
            let v13 := v12
            let v14 := allowance(v10, v13, v3)
            abi_encode_u256(v14, 0)
          }
          case 117300739 {
            abi_encode_string(31840933704928615426292613906591192052886564858731089189578963311002547912704, 7, 0)
          }
          case 2514000705 {
            abi_encode_string(31784391594991486112232083260356792451358613714049171750120207607087736291328, 3, 0)
          }
          case 826074471 {
            abi_encode_u256(18, 0)
          }
          case 2835717307 {
            let v15 := calldataload(4)
            let v16 := mload(0x40)
            if iszero(v16) {
              v16 := 0x80
            }
            mstore(0x40, add(v16, 32))
            mstore(v16, v15)
            let v17 := v16
            let v18 := calldataload(36)
            let v19 := transfer(v17, v18, v3, 0, 0)
            abi_encode_u256(v19, 0)
          }
          case 157198259 {
            let v20 := calldataload(4)
            let v21 := mload(0x40)
            if iszero(v21) {
              v21 := 0x80
            }
            mstore(0x40, add(v21, 32))
            mstore(v21, v20)
            let v22 := v21
            let v23 := calldataload(36)
            let v24 := approve(v22, v23, v3, 0)
            abi_encode_u256(v24, 0)
          }
          case 599290589 {
            let v25 := calldataload(4)
            let v26 := mload(0x40)
            if iszero(v26) {
              v26 := 0x80
            }
            mstore(0x40, add(v26, 32))
            mstore(v26, v25)
            let v27 := v26
            let v28 := calldataload(36)
            let v29 := mload(0x40)
            if iszero(v29) {
              v29 := 0x80
            }
            mstore(0x40, add(v29, 32))
            mstore(v29, v28)
            let v30 := v29
            let v31 := calldataload(68)
            let v32 := transfer_from(v27, v30, v31, v3, 0, 0)
            abi_encode_u256(v32, 0)
          }
          case 1086394137 {
            let v33 := calldataload(4)
            let v34 := mload(0x40)
            if iszero(v34) {
              v34 := 0x80
            }
            mstore(0x40, add(v34, 32))
            mstore(v34, v33)
            let v35 := v34
            let v36 := calldataload(36)
            let v37 := mint(v35, v36, v3, 0, 0)
            abi_encode_u256(v37, 0)
          }
          default {
            revert(0, 0)
          }
      }
      function stor_ptr__Evm_Erc20__c294a0aeae425afd(self, slot) -> ret {
        ret := slot
        leave
      }
      function storagemap_k__v__get_stor__Address_u256__cdd966cb4c9acb9d(self, key) -> ret {
        let v0 := storagemap_k__v__storage_slot_stor__Address_u256__cdd966cb4c9acb9d(self, key)
        let v1 := sload(v0)
        let v2 := u256_wordrepr_from_word(v1)
        ret := v2
        leave
      }
      function storagemap_k__v__get_stor___Address__Address__u256__380d6b10c386a4ee(self, key) -> ret {
        let v0 := storagemap_k__v__storage_slot_stor___Address__Address__u256__380d6b10c386a4ee(self, key)
        let v1 := sload(v0)
        let v2 := u256_wordrepr_from_word(v1)
        ret := v2
        leave
      }
      function storagemap_k__v__set_stor__Address_u256__cdd966cb4c9acb9d(self, key, value) {
        let v0 := storagemap_k__v__storage_slot_stor__Address_u256__cdd966cb4c9acb9d(self, key)
        let v1 := u256_wordrepr_to_word(value)
        sstore(v0, v1)
        leave
      }
      function storagemap_k__v__set_stor___Address__Address__u256__380d6b10c386a4ee(self, key, value) {
        let v0 := storagemap_k__v__storage_slot_stor___Address__Address__u256__380d6b10c386a4ee(self, key)
        let v1 := u256_wordrepr_to_word(value)
        sstore(v0, v1)
        leave
      }
      function storagemap_k__v__storage_slot_stor__Address_u256__cdd966cb4c9acb9d(self, key) -> ret {
        let v0 := mload(64)
        let v1 := address_storagekey_write_key(v0, key)
        let v2 := self
        mstore(add(v0, v1), v2)
        let v3 := keccak256(v0, add(v1, 32))
        ret := v3
        leave
      }
      function storagemap_k__v__storage_slot_stor___Address__Address__u256__380d6b10c386a4ee(self, key) -> ret {
        let v0 := mload(64)
        let v1 := _a__b__storagekey_write_key__Address_Address__397b9a625a435b6f(v0, key)
        let v2 := self
        mstore(add(v0, v1), v2)
        let v3 := keccak256(v0, add(v1, 32))
        ret := v3
        leave
      }
      function transfer(to, amount, erc20, ctx, ops) -> ret {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 32))
        let v1 := caller()
        mstore(v0, v1)
        erc20_transfer_stor(erc20, v0, to, amount, ops)
        ret := 1
        leave
      }
      function transfer_from(from, to, amount, erc20, ctx, ops) -> ret {
        erc20_transfer_from_stor(erc20, from, to, amount, ctx, ops)
        ret := 1
        leave
      }
      function u256_storagekey_write_key(ptr, self) -> ret {
        mstore(ptr, self)
        ret := 32
        leave
      }
      function u256_wordrepr_from_word(word) -> ret {
        ret := word
        leave
      }
      function u256_wordrepr_to_word(self) -> ret {
        ret := self
        leave
      }
      runtime()
      return(0, 0)
    }
  }
}
