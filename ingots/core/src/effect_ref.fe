/// Effect reference traits.
///
/// Fe models effects as implicit "provider" generic parameters. The `EffectRef<T>` marker traits
/// express that a provider type can satisfy a read-only (or mutable) effect whose domain is `T`,
/// while `EffectHandle` captures concrete pointer/handle providers with a runtime representation.
///
/// Backends may define their own concrete provider types, but `core` also provides a small set of
/// general-purpose provider types (`MemPtr<T>`, `StorPtr<T>`) that backends can map onto their
/// runtime model.

/// Effect provider address-space marker.
pub struct Memory {}

/// Effect provider address-space marker: indicates the provider points into immutable calldata.
///
/// Backends may interpret this as an input byte buffer (e.g. EVM calldata via CALLDATALOAD).
pub struct Calldata {}

/// Effect provider address-space marker: indicates the provider points into the target's persistent
/// storage/state.
///
/// Backends decide what "storage" means for their runtime model.
pub struct Storage {}

/// Effect provider address-space marker: indicates the provider points into transient storage.
///
/// Backends may interpret this as a temporary key/value store scoped to a call frame (e.g. EVM
/// transient storage via TLOAD/TSTORE).
pub struct TransientStorage {}

/// Target-specific domain markers (e.g. calldata, transient storage) belong in the target's
/// standard library, not in `core`.

/// Memory pointer to a value of type `T`.
///
/// This is a general-purpose effect provider type. Backends decide how the raw
/// handle maps to runtime memory.
pub struct MemPtr<T> {
    addr: u256
}

/// Pointer/handle to a contract field of type `T`.
///
/// This is a general-purpose effect provider type. Backends decide how the raw
/// handle maps to persistent contract state (e.g. EVM storage slots).
pub struct StorPtr<T> {
    handle: u256
}

/// Marker: `Self` can satisfy a read-only effect whose domain is `Target`.
pub trait EffectRef<Target> {}

/// Marker: `Self` can satisfy a *mutable* effect whose domain is `Target`.
pub trait EffectRefMut<Target>: EffectRef<Target> {}

/// A concrete pointer/handle provider with a runtime representation.
///
/// This is the place to keep `from_raw`/`raw` and address-space metadata.
pub trait EffectHandle {
    type Target
    type AddressSpace

    /// Construct the effect provider from the raw pointer/handle used by the backend.
    fn from_raw(raw: u256) -> Self

    /// Return the raw pointer/handle used by the backend (e.g. memory address or storage slot).
    fn raw(self) -> u256
}

/// Marker: a handle that supports mutable access.
pub trait EffectHandleMut: EffectHandle {}

impl<T> EffectRef<T> for T {}
// Mutability is checked at the term level.
impl<T> EffectRefMut<T> for T {}

impl<T> EffectHandle for MemPtr<T> {
    type Target = T
    type AddressSpace = Memory

    fn from_raw(raw: u256) -> Self {
        Self { addr: raw }
    }

    fn raw(self) -> u256 {
        self.addr
    }
}
impl<T> EffectHandleMut for MemPtr<T> {}

impl<T> EffectRef<T> for MemPtr<T> {}
impl<T> EffectRefMut<T> for MemPtr<T> {}

impl<T> EffectHandle for StorPtr<T> {
    type Target = T
    type AddressSpace = Storage

    fn from_raw(raw: u256) -> Self {
        Self { handle: raw }
    }

    fn raw(self) -> u256 {
        self.handle
    }
}
impl<T> EffectHandleMut for StorPtr<T> {}

impl<T> EffectRef<T> for StorPtr<T> {}
impl<T> EffectRefMut<T> for StorPtr<T> {}
