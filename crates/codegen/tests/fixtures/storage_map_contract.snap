---
source: crates/codegen/tests/yul.rs
expression: output
input_file: tests/fixtures/storage_map_contract.fe
---
object "BalanceMap" {
  code {
    function init() {
      let v0 := 0
      let v1 := datasize("BalanceMap_deployed")
      let v2 := dataoffset("BalanceMap_deployed")
      codecopy(0, v2, v1)
      return(0, v1)
    }
    init()
  }

  object "BalanceMap_deployed" {
    code {
      function abi_encode(value, ops) {
        let v0 := 0
        mstore(v0, value)
        return(v0, 32)
      }
      function get_allowance(addr, allowances) -> ret {
        let v0 := storagemap_k__v__get_stor__u256_u256__cc308d1bea3fb6e4(allowances, addr)
        ret := v0
        leave
      }
      function get_balance(addr, balances) -> ret {
        let v0 := storagemap_k__v__get_stor__u256_u256__cc308d1bea3fb6e4(balances, addr)
        ret := v0
        leave
      }
      function runtime() {
        let v0 := 0
        let v1 := stor_ptr__Evm_StorageMap_u256__u256___a32410dee911f369(v0, 0)
        let v2 := stor_ptr__Evm_StorageMap_u256__u256___a32410dee911f369(v0, 1)
        let v3 := calldataload(0)
        let v4 := shr(224, v3)
        switch v4
          case 2630350600 {
            let v5 := calldataload(4)
            let v6 := v1
            let v7 := get_balance(v5, v6)
            let v8 := v7
            abi_encode(v8, 0)
          }
          case 1246470123 {
            let v9 := calldataload(4)
            let v10 := calldataload(36)
            let v11 := v1
            set_balance(v9, v10, v11)
            abi_encode(0, 0)
          }
          case 2430412327 {
            let v12 := calldataload(4)
            let v13 := calldataload(36)
            let v14 := calldataload(68)
            let v15 := v1
            let v16 := transfer(v12, v13, v14, v15)
            let v17 := v16
            abi_encode(v17, 0)
          }
          case 3378517838 {
            let v18 := calldataload(4)
            let v19 := v2
            let v20 := get_allowance(v18, v19)
            let v21 := v20
            abi_encode(v21, 0)
          }
          case 197806145 {
            let v22 := calldataload(4)
            let v23 := calldataload(36)
            let v24 := v2
            set_allowance(v22, v23, v24)
            abi_encode(0, 0)
          }
          default {
            return(0, 0)
          }
      }
      function set_allowance(addr, value, allowances) {
        storagemap_k__v__set_stor__u256_u256__cc308d1bea3fb6e4(allowances, addr, value)
        leave
      }
      function set_balance(addr, value, balances) {
        storagemap_k__v__set_stor__u256_u256__cc308d1bea3fb6e4(balances, addr, value)
        leave
      }
      function stor_ptr__Evm_StorageMap_u256__u256___a32410dee911f369(self, slot) -> ret {
        let v0 := slot
        ret := v0
        leave
      }
      function storagemap_k__v__get_stor__u256_u256__cc308d1bea3fb6e4(self, key) -> ret {
        let v0 := storagemap_k__v__storage_slot_stor__u256_u256__cc308d1bea3fb6e4(self, key)
        let v1 := sload(v0)
        let v2 := u256_wordrepr_from_word(v1)
        ret := v2
        leave
      }
      function storagemap_k__v__set_stor__u256_u256__cc308d1bea3fb6e4(self, key, value) {
        let v0 := storagemap_k__v__storage_slot_stor__u256_u256__cc308d1bea3fb6e4(self, key)
        let v1 := u256_wordrepr_to_word(value)
        sstore(v0, v1)
        leave
      }
      function storagemap_k__v__storage_slot_stor__u256_u256__cc308d1bea3fb6e4(self, key) -> ret {
        let v0 := u256_storagekey_write_key(0, key)
        let v1 := self
        mstore(v0, v1)
        let v2 := keccak256(0, add(v0, 32))
        ret := v2
        leave
      }
      function transfer(from, to, amount, balances) -> ret {
        let v0 := storagemap_k__v__get_stor__u256_u256__cc308d1bea3fb6e4(balances, from)
        let v1 := lt(v0, amount)
        if v1 {
          ret := 1
          leave
        }
        if iszero(v1) {
          let v2 := storagemap_k__v__get_stor__u256_u256__cc308d1bea3fb6e4(balances, to)
          storagemap_k__v__set_stor__u256_u256__cc308d1bea3fb6e4(balances, from, sub(v0, amount))
          storagemap_k__v__set_stor__u256_u256__cc308d1bea3fb6e4(balances, to, add(v2, amount))
          ret := 0
          leave
        }
      }
      function u256_storagekey_write_key(ptr, self) -> ret {
        mstore(ptr, self)
        ret := 32
        leave
      }
      function u256_wordrepr_from_word(word) -> ret {
        ret := word
        leave
      }
      function u256_wordrepr_to_word(self) -> ret {
        ret := self
        leave
      }
      runtime()
      return(0, 0)
    }
  }
}
