---
source: crates/hir/tests/desugar.rs
expression: output
input_file: test_files/desugar/contract_and_effects.fe
---
use core::prelude::*

mod __Counter {
    use super::*
    use core::size_of
    use std::evm::effects::Evm
    use std::evm::effects::RawOps
    use std::evm::effects::RawStorage
    use std::evm::effects::StorPtr
    use std::evm::contract_field_slot
    use std::evm::calldata::CallData
    use std::abi::Sol
    use std::abi::sol::SolDecoder
    use std::abi::sol::SolEncoder
    use std::abi::sol::encoded_size

    fn recv_CounterMsg_Increment_0_0(args: CounterMsg::Increment::Args) uses (mut count: u64) {
        return {
            count += 1
        }
    }

    fn recv_CounterMsg_Get_0_1(args: CounterMsg::Get::Args) -> u64 uses (count: u64) {
        return {
            count
        }
    }

    fn init_contract(start: u64) uses (mut count: u64) {
        return {
            count = start
        }
    }

    #[contract_init(Counter)]
    fn init() uses (mut evm: Evm) {
        let mut count: StorPtr<u64> = evm.stor_ptr(contract_field_slot(0))
        let __calldata = CallData {  }
        let mut __d = SolDecoder<CallData>::new(__calldata)
        if evm.calldatasize() < encoded_size<u64>() {
            evm.revert(0, 0)
        }
        let start: u64 = u64::decode(__d)
        with (count) { init_contract(start) }
        let __len = evm.code_region_len(runtime)
        let __offset = evm.code_region_offset(runtime)
        evm.codecopy(0, __offset, __len)
        evm.return_data(0, __len)
    }

    #[contract_runtime(Counter)]
    fn runtime() uses (mut evm: Evm) {
        let mut count: StorPtr<u64> = evm.stor_ptr(contract_field_slot(0))
        let __calldata = CallData {  }
        if evm.calldatasize() < size_of<Sol::Selector>() {
            evm.revert(0, 0)
        }
        let __selector = Sol::selector_from_prefix(evm.calldataload(0))
        match __selector {
            CounterMsg::Increment::SELECTOR => {
                let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
                if evm.calldatasize() < size_of<Sol::Selector>() + encoded_size<CounterMsg::Increment::Args>() {
                    evm.revert(0, 0)
                }
                let __args: CounterMsg::Increment::Args = CounterMsg::Increment::Args::decode(__d)
                with (count) { recv_CounterMsg_Increment_0_0(__args) }
                evm.return_data(0, 0)
            },
            CounterMsg::Get::SELECTOR => {
                let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
                if evm.calldatasize() < size_of<Sol::Selector>() + encoded_size<CounterMsg::Get::Args>() {
                    evm.revert(0, 0)
                }
                let __args: CounterMsg::Get::Args = CounterMsg::Get::Args::decode(__d)
                let __result = with (count) { recv_CounterMsg_Get_0_1(__args) }
                let mut __enc = SolEncoder::new()
                __enc.reserve_head(32)
                __result.encode(__enc)
                let __out = __enc.finish()
                evm.return_data(__out.0, __out.1)
            },
            _ => evm.revert(0, 0),
        }
    }
}

mod CounterMsg {
    use core::prelude::*
    use super::*

    pub struct Increment {}

    impl core::message::MsgVariant<std::abi::Sol> for Increment {
        type Args = ()
        type Return = ()
        const SELECTOR: u32 = 1
    }

    impl Increment {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            return Self {  }
        }
    
    }

    pub struct Get {}

    impl core::message::MsgVariant<std::abi::Sol> for Get {
        type Args = ()
        type Return = u64
        const SELECTOR: u32 = 2
    }

    impl Get {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            return Self {  }
        }
    
    }
}

pub struct Storage {
    pub value: u256,
}

fn use_storage() uses (mut Storage) {
    Storage.value = 100
}
