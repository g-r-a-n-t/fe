---
source: crates/codegen/tests/yul.rs
expression: desugared
---
use core::prelude::*

mod EchoMsg {
    use core::prelude::*
    use super::*

    pub struct Answer {}

    impl core::message::MsgVariant<std::abi::Sol> for Answer {
        type Args = ()
        type Return = u256
        const SELECTOR: u32 = 1
    }

    impl Answer {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            return Self {  }
        }
    
    }

    pub struct Echo {
        pub x: u256,
    }

    impl core::message::MsgVariant<std::abi::Sol> for Echo {
        type Args = (u256)
        type Return = u256
        const SELECTOR: u32 = 2
    }

    impl Echo {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            let x = u256::decode(d)
            return Self { x: x }
        }
    
    }

    pub struct GetX {}

    impl core::message::MsgVariant<std::abi::Sol> for GetX {
        type Args = ()
        type Return = u256
        const SELECTOR: u32 = 3
    }

    impl GetX {
        pub fn decode(mut _ d: std::abi::sol::SolDecoder<std::evm::calldata::CallData>) -> Self {
            return Self {  }
        }
    
    }
}

pub struct Foo {
    x: u256,
    y: u256,
}

mod __EchoContract {
    use super::*
    use core::size_of
    use std::evm::effects::Evm
    use std::evm::effects::RawOps
    use std::evm::effects::RawStorage
    use std::evm::effects::StorPtr
    use std::evm::contract_field_slot
    use std::evm::calldata::CallData
    use std::abi::Sol
    use std::abi::sol::SolDecoder
    use std::abi::sol::SolEncoder
    use std::abi::sol::encoded_size

    fn recv_EchoMsg_Answer_0_0(args: EchoMsg::Answer::Args) -> u256 {
        return {
            42
        }
    }

    fn recv_EchoMsg_Echo_0_1(args: EchoMsg::Echo::Args) -> u256 {
        let x = args.0
        return {
            x
        }
    }

    fn recv_EchoMsg_GetX_0_2(args: EchoMsg::GetX::Args) -> u256 uses (state: Foo) {
        return {
            state.x
        }
    }

    fn init_contract(x: u256, y: u256) uses (mut state: Foo) {
        return {
            state.x = x
            state.y = y
        }
    }

    #[contract_init(EchoContract)]
    fn init() uses (mut evm: Evm) {
        let mut state: StorPtr<Foo> = evm.stor_ptr(contract_field_slot(0))
        let __calldata = CallData {  }
        let mut __d = SolDecoder<CallData>::new(__calldata)
        if evm.calldatasize() < encoded_size<u256>() + encoded_size<u256>() {
            evm.revert(0, 0)
        }
        let x: u256 = u256::decode(__d)
        let y: u256 = u256::decode(__d)
        with (state) { init_contract(x, y) }
        let __len = evm.code_region_len(runtime)
        let __offset = evm.code_region_offset(runtime)
        evm.codecopy(0, __offset, __len)
        evm.return_data(0, __len)
    }

    #[contract_runtime(EchoContract)]
    fn runtime() uses (mut evm: Evm) {
        let mut state: StorPtr<Foo> = evm.stor_ptr(contract_field_slot(0))
        let __calldata = CallData {  }
        if evm.calldatasize() < size_of<Sol::Selector>() {
            evm.revert(0, 0)
        }
        let __selector = Sol::selector_from_prefix(evm.calldataload(0))
        match __selector {
            EchoMsg::Answer::SELECTOR => {
                let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
                if evm.calldatasize() < size_of<Sol::Selector>() + encoded_size<EchoMsg::Answer::Args>() {
                    evm.revert(0, 0)
                }
                let __args: EchoMsg::Answer::Args = EchoMsg::Answer::Args::decode(__d)
                let __result = recv_EchoMsg_Answer_0_0(__args)
                let mut __enc = SolEncoder::new()
                __enc.reserve_head(32)
                __result.encode(__enc)
                let __out = __enc.finish()
                evm.return_data(__out.0, __out.1)
            },
            EchoMsg::Echo::SELECTOR => {
                let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
                if evm.calldatasize() < size_of<Sol::Selector>() + encoded_size<EchoMsg::Echo::Args>() {
                    evm.revert(0, 0)
                }
                let __args: EchoMsg::Echo::Args = EchoMsg::Echo::Args::decode(__d)
                let __result = recv_EchoMsg_Echo_0_1(__args)
                let mut __enc = SolEncoder::new()
                __enc.reserve_head(32)
                __result.encode(__enc)
                let __out = __enc.finish()
                evm.return_data(__out.0, __out.1)
            },
            EchoMsg::GetX::SELECTOR => {
                let mut __d = SolDecoder<CallData>::with_base(__calldata, size_of<Sol::Selector>())
                if evm.calldatasize() < size_of<Sol::Selector>() + encoded_size<EchoMsg::GetX::Args>() {
                    evm.revert(0, 0)
                }
                let __args: EchoMsg::GetX::Args = EchoMsg::GetX::Args::decode(__d)
                let __result = with (state) { recv_EchoMsg_GetX_0_2(__args) }
                let mut __enc = SolEncoder::new()
                __enc.reserve_head(32)
                __result.encode(__enc)
                let __out = __enc.finish()
                evm.return_data(__out.0, __out.1)
            },
            _ => evm.revert(0, 0),
        }
    }
}
