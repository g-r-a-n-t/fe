---
source: crates/codegen/tests/yul.rs
expression: output
input_file: tests/fixtures/high_level_contract.fe
---
object "EchoContract" {
  code {
    function calldata_byteinput_word_at(self, byte_offset) -> ret {
      let v0 := calldataload(byte_offset)
      ret := v0
      leave
    }
    function cursor_i__new__CallData__b9ab8dc8a4b2f9e(input) -> ret {
      let v0 := mload(0x40)
      if iszero(v0) {
        v0 := 0x80
      }
      mstore(0x40, add(v0, 32))
      pop(v0)
      mstore(v0, 0)
      let v1 := v0
      ret := v1
      leave
    }
    function cursor_i__read_word_mem__CallData__b9ab8dc8a4b2f9e(self) -> ret {
      pop(self)
      let v0 := mload(self)
      let v1 := calldata_byteinput_word_at(0, v0)
      let v2 := mload(self)
      mstore(self, add(v2, 32))
      ret := v1
      leave
    }
    function init() {
      let v0 := 0
      let v1 := stor_ptr__Evm_Foo__c3089d776807df8e(v0, 0)
      let v2 := soldecoder_i__new__CallData__b9ab8dc8a4b2f9e(0)
      let v3 := calldatasize()
      let v4 := lt(v3, add(32, 32))
      if v4 {
        revert(0, 0)
      }
      let v5 := u256_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(v2)
      let v6 := u256_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(v2)
      let v7 := v1
      init_contract(v5, v6, v7)
      let v8 := datasize("EchoContract_deployed")
      let v9 := dataoffset("EchoContract_deployed")
      codecopy(0, v9, v8)
      return(0, v8)
    }
    function init_contract(x, y, state) {
      sstore(state, x)
      sstore(add(state, 1), y)
      leave
    }
    function soldecoder_i__abidecoder_read_word__CallData__b9ab8dc8a4b2f9e(self) -> ret {
      let v0 := cursor_i__read_word_mem__CallData__b9ab8dc8a4b2f9e(self)
      ret := v0
      leave
    }
    function soldecoder_i__new__CallData__b9ab8dc8a4b2f9e(input) -> ret {
      let v0 := cursor_i__new__CallData__b9ab8dc8a4b2f9e(input)
      let v1 := mload(0x40)
      if iszero(v1) {
        v1 := 0x80
      }
      mstore(0x40, add(v1, 64))
      let v2 := v0
      mstore(v1, mload(v2))
      mstore(add(v1, 32), 0)
      let v3 := v1
      ret := v3
      leave
    }
    function stor_ptr__Evm_Foo__c3089d776807df8e(self, slot) -> ret {
      let v0 := slot
      ret := v0
      leave
    }
    function u256_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d) -> ret {
      let v0 := soldecoder_i__abidecoder_read_word__CallData__b9ab8dc8a4b2f9e(d)
      ret := v0
      leave
    }
    init()
  }

  object "EchoContract_deployed" {
    code {
      function ___decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d) {
        leave
      }
      function _t0__decode_decode__Sol_u256_SolDecoder_CallData___51fc2f6931ec5edc(d) -> ret {
        let v0 := u256_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d)
        let v1 := mload(0x40)
        if iszero(v1) {
          v1 := 0x80
        }
        mstore(0x40, add(v1, 32))
        mstore(v1, v0)
        ret := v1
        leave
      }
      function alloc(size) -> ret {
        let v0 := mload(64)
        let v1 := eq(v0, 0)
        if v1 {
          v0 := 128
        }
        mstore(64, add(v0, size))
        ret := v0
        leave
      }
      function calldata_byteinput_word_at(self, byte_offset) -> ret {
        let v0 := calldataload(byte_offset)
        ret := v0
        leave
      }
      function cursor_i__fork_mem__CallData__b9ab8dc8a4b2f9e(self, pos) -> ret {
        pop(self)
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 32))
        pop(v0)
        mstore(v0, pos)
        let v1 := v0
        ret := v1
        leave
      }
      function cursor_i__new__CallData__b9ab8dc8a4b2f9e(input) -> ret {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 32))
        pop(v0)
        mstore(v0, 0)
        let v1 := v0
        ret := v1
        leave
      }
      function cursor_i__read_word_mem__CallData__b9ab8dc8a4b2f9e(self) -> ret {
        pop(self)
        let v0 := mload(self)
        let v1 := calldata_byteinput_word_at(0, v0)
        let v2 := mload(self)
        mstore(self, add(v2, 32))
        ret := v1
        leave
      }
      function recv_EchoMsg_Answer_0_0(args) -> ret {
        ret := 42
        leave
      }
      function recv_EchoMsg_Echo_0_1(args) -> ret {
        let v0 := mload(args)
        ret := v0
        leave
      }
      function recv_EchoMsg_GetX_0_2(args, state) -> ret {
        let v0 := sload(state)
        ret := v0
        leave
      }
      function runtime() {
        let v0 := 0
        let v1 := stor_ptr__Evm_Foo__c3089d776807df8e(v0, 0)
        let v2 := calldatasize()
        let v3 := lt(v2, 4)
        if v3 {
          revert(0, 0)
        }
        let v4 := calldataload(0)
        let v5 := sol_abi_selector_from_prefix(v4)
        switch v5
          case 1 {
            let v6 := soldecoder_i__with_base__CallData__b9ab8dc8a4b2f9e(0, 4)
            let v7 := calldatasize()
            let v8 := lt(v7, add(4, 0))
            if v8 {
              revert(0, 0)
            }
            ___decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(v6)
            let v9 := recv_EchoMsg_Answer_0_0(0)
            let v10 := solencoder_new()
            let v11 := solencoder_abiencoder_reserve_head(v10, 32)
            pop(v11)
            u256_encode_encode__Sol_SolEncoder__dce63ad1a1fe4ae2(v9, v10)
            let v12 := solencoder_abiencoder_finish(v10)
            let v13 := mload(v12)
            let v14 := mload(add(v12, 32))
            return(v13, v14)
          }
          case 2 {
            let v15 := soldecoder_i__with_base__CallData__b9ab8dc8a4b2f9e(0, 4)
            let v16 := calldatasize()
            let v17 := lt(v16, add(4, 32))
            if v17 {
              revert(0, 0)
            }
            let v18 := _t0__decode_decode__Sol_u256_SolDecoder_CallData___51fc2f6931ec5edc(v15)
            let v19 := recv_EchoMsg_Echo_0_1(v18)
            let v20 := solencoder_new()
            let v21 := solencoder_abiencoder_reserve_head(v20, 32)
            pop(v21)
            u256_encode_encode__Sol_SolEncoder__dce63ad1a1fe4ae2(v19, v20)
            let v22 := solencoder_abiencoder_finish(v20)
            let v23 := mload(v22)
            let v24 := mload(add(v22, 32))
            return(v23, v24)
          }
          case 3 {
            let v25 := soldecoder_i__with_base__CallData__b9ab8dc8a4b2f9e(0, 4)
            let v26 := calldatasize()
            let v27 := lt(v26, add(4, 0))
            if v27 {
              revert(0, 0)
            }
            ___decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(v25)
            let v28 := v1
            let v29 := recv_EchoMsg_GetX_0_2(0, v28)
            let v30 := v29
            let v31 := solencoder_new()
            let v32 := solencoder_abiencoder_reserve_head(v31, 32)
            pop(v32)
            u256_encode_encode__Sol_SolEncoder__dce63ad1a1fe4ae2(v30, v31)
            let v33 := solencoder_abiencoder_finish(v31)
            let v34 := mload(v33)
            let v35 := mload(add(v33, 32))
            return(v34, v35)
          }
          default {
            revert(0, 0)
          }
      }
      function sol_abi_selector_from_prefix(prefix) -> ret {
        let v0 := shr(224, prefix)
        ret := v0
        leave
      }
      function soldecoder_i__abidecoder_read_word__CallData__b9ab8dc8a4b2f9e(self) -> ret {
        let v0 := cursor_i__read_word_mem__CallData__b9ab8dc8a4b2f9e(self)
        ret := v0
        leave
      }
      function soldecoder_i__with_base__CallData__b9ab8dc8a4b2f9e(input, base) -> ret {
        let v0 := cursor_i__new__CallData__b9ab8dc8a4b2f9e(input)
        let v1 := cursor_i__fork_mem__CallData__b9ab8dc8a4b2f9e(v0, base)
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 64))
        let v3 := v1
        mstore(v2, mload(v3))
        mstore(add(v2, 32), base)
        let v4 := v2
        ret := v4
        leave
      }
      function solencoder_abiencoder_finish(self) -> ret {
        let v0 := mload(self)
        let v1 := mload(add(self, 64))
        let v2 := mload(0x40)
        if iszero(v2) {
          v2 := 0x80
        }
        mstore(0x40, add(v2, 64))
        mstore(v2, v0)
        mstore(add(v2, 32), sub(v1, v0))
        ret := v2
        leave
      }
      function solencoder_abiencoder_reserve_head(self, bytes) -> ret {
        solencoder_ensure_init_mem(self, bytes)
        let v0 := mload(self)
        ret := v0
        leave
      }
      function solencoder_abiencoder_write_word(self, v) {
        let v0 := mload(add(self, 32))
        mstore(v0, v)
        mstore(add(self, 32), add(v0, 32))
        leave
      }
      function solencoder_ensure_init_mem(self, bytes) {
        let v0 := mload(self)
        let v1 := eq(v0, 0)
        if v1 {
          let v2 := alloc(bytes)
          mstore(self, v2)
          mstore(add(self, 32), v2)
          mstore(add(self, 64), add(v2, bytes))
        }
        leave
      }
      function solencoder_new() -> ret {
        let v0 := mload(0x40)
        if iszero(v0) {
          v0 := 0x80
        }
        mstore(0x40, add(v0, 96))
        mstore(v0, 0)
        mstore(add(v0, 32), 0)
        mstore(add(v0, 64), 0)
        let v1 := v0
        ret := v1
        leave
      }
      function stor_ptr__Evm_Foo__c3089d776807df8e(self, slot) -> ret {
        let v0 := slot
        ret := v0
        leave
      }
      function u256_decode_decode__Sol_SolDecoder_CallData___828c6f2e3bda3cab(d) -> ret {
        let v0 := soldecoder_i__abidecoder_read_word__CallData__b9ab8dc8a4b2f9e(d)
        ret := v0
        leave
      }
      function u256_encode_encode__Sol_SolEncoder__dce63ad1a1fe4ae2(self, e) {
        solencoder_abiencoder_write_word(e, self)
        leave
      }
      runtime()
      return(0, 0)
    }
  }
}
